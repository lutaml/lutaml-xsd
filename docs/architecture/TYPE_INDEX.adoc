---
layout: default
title: Type index implementation
nav_order: 3
parent: Architecture
---
= Type Index Implementation
:toc:
:toclevels: 3

== Purpose

This document provides detailed technical documentation on the type index implementation in lutaml-xsd. It explains how types are indexed during schema parsing, how lookups work, and the data structures used for fast qualified name resolution.

== General

The type index ([`TypeIndex`](../../lib/lutaml/xsd/schema_repository/type_index.rb:8)) is a critical component that enables fast type lookups across multiple schemas and namespaces. It provides O(1) hash-based lookups for type definitions using qualified names in multiple formats.

The index is built during schema parsing and resolution, creating a comprehensive map of all type definitions across the schema collection. This eliminates the need for linear searches through schema structures and enables instant type resolution.

== Index structure

The type index organizes type definitions in three complementary dimensions for flexible querying:

[source,ruby]
----
@index = {
  # Clark notation keys → type information
  "{http://www.opengis.net/gml/3.2}CodeType" => {
    type: :complex_type,
    definition: <ComplexType object>,
    namespace: "http://www.opengis.net/gml/3.2",
    schema_file: "basicTypes.xsd"
  },
  "{http://www.opengis.net/gml/3.2}MeasureType" => {
    type: :complex_type,
    definition: <ComplexType object>,
    namespace: "http://www.opengis.net/gml/3.2",
    schema_file: "basicTypes.xsd"
  },
  "{http://www.opengis.net/citygml/2.0}Building" => {
    type: :element,
    definition: <Element object>,
    namespace: "http://www.opengis.net/citygml/2.0",
    schema_file: "building.xsd"
  }
  # ... thousands more entries
}
----

=== Index dimensions

==== 1. By namespace

Enables querying all types within a specific namespace:

[source,ruby]
----
# Find all types in GML namespace
types = index.find_all_in_namespace("http://www.opengis.net/gml/3.2")
# Returns array of type information hashes
----

==== 2. By qualified name

Enables lookup using Clark notation (the primary key):

[source,ruby]
----
# Lookup by Clark notation
type_info = index.find("{http://www.opengis.net/gml/3.2}CodeType")
# Returns type information hash or nil
----

==== 3. By category

Enables filtering types by their classification:

[source,ruby]
----
# Get statistics by category
stats = index.statistics
stats[:by_type][:complex_type]  # => 1356
stats[:by_type][:simple_type]   # => 92
stats[:by_type][:element]       # => 1221
----

== Building the index

The index is built incrementally as schemas are parsed:

=== During schema parsing

[source]
----
Schema Parsing Flow:
═══════════════════

1. Parse main schema
   ┌────────────────────┐
   │ urbanFunction.xsd  │
   └─────────┬──────────┘
             │
             ▼
   ┌────────────────────┐
   │ Index schema       │
   │ • Complex types    │
   │ • Simple types     │
   │ • Elements         │
   │ • Attribute groups │
   │ • Groups           │
   └─────────┬──────────┘
             │
             ▼
2. Process imports
   ┌────────────────────┐
   │ <xs:import>        │
   │ urbanObject.xsd    │
   └─────────┬──────────┘
             │
             ▼
   ┌────────────────────┐
   │ Parse & index      │
   │ imported schema    │
   └─────────┬──────────┘
             │
             ▼
3. Process includes
   ┌────────────────────┐
   │ <xs:include>       │
   │ common.xsd         │
   └─────────┬──────────┘
             │
             ▼
   ┌────────────────────┐
   │ Parse & index      │
   │ included schema    │
   └─────────┬──────────┘
             │
             ▼
4. Complete index
   ┌────────────────────┐
   │ All types indexed  │
   │ Ready for lookups  │
   └────────────────────┘
----

=== Index building algorithm

The [`TypeIndex#build_from_schemas`](../../lib/lutaml/xsd/schema_repository/type_index.rb:16) method orchestrates indexing:

[source,ruby]
----
def build_from_schemas(schemas)
  schemas.each do |file_path, schema|
    index_schema(schema, file_path)
  end
end
----

For each schema, the [`index_schema`](../../lib/lutaml/xsd/schema_repository/type_index.rb:25) method indexes all type collections:

[source,ruby]
----
def index_schema(schema, file_path)
  namespace = schema.target_namespace

  # Index each type collection
  index_collection(schema.simple_type, namespace, file_path, :simple_type)
  index_collection(schema.complex_type, namespace, file_path, :complex_type)
  index_collection(schema.element, namespace, file_path, :element)
  index_collection(schema.attribute_group, namespace, file_path, :attribute_group)
  index_collection(schema.group, namespace, file_path, :group)
end
----

The [`index_collection`](../../lib/lutaml/xsd/schema_repository/type_index.rb:130) method processes each type:

[source,ruby]
----
def index_collection(collection, namespace, file_path, type_symbol)
  return unless collection && !collection.empty?

  collection.each do |item|
    next unless item&.name

    # Build Clark notation key
    clark_key = build_clark_key(namespace, item.name)

    # Store type information
    @index[clark_key] = {
      type: type_symbol,           # :complex_type, :simple_type, etc.
      definition: item,             # The actual type object
      namespace: namespace,         # Namespace URI
      schema_file: file_path        # Source file
    }
  end
end
----

=== Clark notation keys

The index uses Clark notation as the primary key format:

[source,ruby]
----
def build_clark_key(namespace, local_name)
  if namespace && !namespace.empty?
    "{#{namespace}}#{local_name}"
  else
    local_name  # No namespace
  end
end
----

Examples:

```
{http://www.opengis.net/gml/3.2}CodeType
{http://www.opengis.net/citygml/2.0}Building
{https://www.geospatial.jp/iur/uro/3.2}BuildingType
```

== Fast lookup mechanisms

The index provides multiple lookup methods optimized for different use cases:

=== Direct lookup by Clark key

O(1) hash lookup using Clark notation:

[source,ruby]
----
# Direct hash lookup - fastest
type_info = index.find("{http://www.opengis.net/gml/3.2}CodeType")

if type_info
  type_info[:type]        # => :complex_type
  type_info[:definition]  # => <ComplexType object>
  type_info[:namespace]   # => "http://www.opengis.net/gml/3.2"
  type_info[:schema_file] # => "basicTypes.xsd"
end
----

Implementation:

[source,ruby]
----
def find(clark_key)
  @index[clark_key]  # O(1) hash lookup
end
----

=== Lookup by namespace and name

Convenience method that builds Clark key:

[source,ruby]
----
# Lookup by namespace + local name
type_info = index.find_by_namespace_and_name(
  "http://www.opengis.net/gml/3.2",
  "CodeType"
)
----

Implementation:

[source,ruby]
----
def find_by_namespace_and_name(namespace, local_name)
  return nil if local_name.nil?

  clark_key = build_clark_key(namespace, local_name)
  find(clark_key)  # Delegates to direct lookup
end
----

=== Find all in namespace

Get all types within a namespace:

[source,ruby]
----
# Get all GML types
gml_types = index.find_all_in_namespace(
  "http://www.opengis.net/gml/3.2"
)
# Returns array of type information hashes
----

Implementation:

[source,ruby]
----
def find_all_in_namespace(namespace)
  @index.select { |key, _| key.start_with?("{#{namespace}}") }.values
end
----

=== Similarity suggestions

Find similar type names for error messages:

[source,ruby]
----
# Get suggestions for misspelled type
suggestions = index.suggest_similar(
  "http://www.opengis.net/gml/3.2",
  "CodeTypo",  # Misspelled
  limit: 5
)
# => ["CodeType", "CodeWithAuthorityType", "CodeOrNilReasonListType"]
----

Implementation:

[source,ruby]
----
def suggest_similar(namespace, local_name, limit: 5)
  types_in_namespace = find_all_in_namespace(namespace)
  return [] if types_in_namespace.empty?

  # Simple similarity: substring matching
  similar = types_in_namespace.select do |type_info|
    name = type_info[:definition]&.name
    next false unless name

    # Check if search term is contained in type name or vice versa
    name.downcase.include?(local_name.downcase) ||
      local_name.downcase.include?(name.downcase)
  end

  similar.map { |info| info[:definition]&.name }.compact.take(limit)
end
----

== Index serialization

The index can be serialized for package distribution:

=== Serialization format

For packages, the index is converted to [`TypeIndexEntry`](../../lib/lutaml/xsd/type_index_entry.rb:6) objects:

[source,ruby]
----
class TypeIndexEntry < Lutaml::Model::Serializable
  attribute :clark_key, :string
  attribute :type_category, :string
  attribute :namespace, :string
  attribute :local_name, :string
  attribute :schema_file, :string
end
----

Example serialized entry:

[source,yaml]
----
clark_key: "{http://www.opengis.net/gml/3.2}CodeType"
type_category: "complex_type"
namespace: "http://www.opengis.net/gml/3.2"
local_name: "CodeType"
schema_file: "basicTypes.xsd"
----

=== Creating index entries

Convert from index info hash to serializable entry:

[source,ruby]
----
def self.from_index_info(clark_key, info)
  new(
    clark_key: clark_key,
    type_category: info[:type].to_s,
    namespace: info[:namespace],
    local_name: info[:definition]&.name,
    schema_file: info[:schema_file]
  )
end
----

=== Serialization workflow

[source]
----
Index Serialization:
═══════════════════

1. Build index from schemas
   ┌────────────────────────────┐
   │ TypeIndex@index (Hash)     │
   │  {clark_key} => info_hash  │
   └──────────┬─────────────────┘
              │
              ▼
2. Convert to entries
   ┌────────────────────────────┐
   │ TypeIndexEntry objects     │
   │  Array of serializable     │
   │  objects                   │
   └──────────┬─────────────────┘
              │
              ▼
3. Serialize to format
   ┌────────────────────────────┐
   │ Marshal/JSON/YAML          │
   │  Based on package config   │
   └──────────┬─────────────────┘
              │
              ▼
4. Write to package
   ┌────────────────────────────┐
   │ type_index.marshal         │
   │  in .lxr package           │
   └────────────────────────────┘
----

== Integration with SchemaRepository

The type index is used by [`SchemaRepository#find_type`](../../lib/lutaml/xsd/schema_repository.rb:171) for qualified name resolution:

=== Resolution workflow

[source]
----
Type Resolution Flow:
════════════════════

User Query: "gml:CodeType"
         │
         ▼
┌─────────────────────────────┐
│ QualifiedNameParser         │
│ Parse qualified name        │
│  prefix: "gml"              │
│  local_name: "CodeType"     │
└──────────┬──────────────────┘
           │
           ▼
┌─────────────────────────────┐
│ NamespaceRegistry           │
│ Resolve prefix → URI        │
│  "gml" →                    │
│  "http://.../gml/3.2"       │
└──────────┬──────────────────┘
           │
           ▼
┌─────────────────────────────┐
│ TypeIndex                   │
│ Lookup by namespace + name  │
│  namespace: http://.../gml  │
│  local_name: CodeType       │
└──────────┬──────────────────┘
           │
           ▼
┌─────────────────────────────┐
│ TypeResolutionResult        │
│  found?: true               │
│  type: ComplexType          │
│  namespace: http://.../gml  │
│  schema_file: basicTypes.xsd│
└─────────────────────────────┘
----

=== Code example

[source,ruby]
----
# In SchemaRepository#find_type(qname)

# 1. Parse qualified name
parsed = QualifiedNameParser.parse(qname, @namespace_registry)
# => { prefix: "gml", local_name: "CodeType", namespace: "http://..." }

# 2. Look up in type index
type_info = @type_index.find_by_namespace_and_name(
  parsed[:namespace],
  parsed[:local_name]
)

# 3. Return result
if type_info
  TypeResolutionResult.success(
    qname: qname,
    namespace: type_info[:namespace],
    local_name: type_info[:definition].name,
    definition: type_info[:definition],
    schema_file: type_info[:schema_file]
  )
else
  TypeResolutionResult.failure(...)
end
----

== Statistics and introspection

The index provides statistics for package metadata:

=== Statistics method

[source,ruby]
----
def statistics
  type_counts = Hash.new(0)
  @index.each_value do |info|
    type_counts[info[:type]] += 1
  end

  {
    total_types: @index.size,
    by_type: type_counts,
    namespaces: namespace_count
  }
end
----

Example output:

[source,ruby]
----
{
  total_types: 2764,
  by_type: {
    complex_type: 1356,
    simple_type: 92,
    element: 1221,
    attribute_group: 68,
    group: 27
  },
  namespaces: 34
}
----

=== Namespace count

Count unique namespaces in index:

[source,ruby]
----
def namespace_count
  @index.values.map { |info| info[:namespace] }.compact.uniq.size
end
----

== Complete examples

=== Example 1: Building and querying an index

[source,ruby]
----
require 'lutaml/xsd'

# Create repository and parse schemas
repo = Lutaml::Xsd::SchemaRepository.new

# Configure namespaces
repo.configure_namespace(prefix: 'gml', uri: 'http://www.opengis.net/gml/3.2')
repo.configure_namespace(prefix: 'uro', uri: 'https://www.geospatial.jp/iur/uro/3.2')

# Parse schemas (automatically builds index)
xsd_content = File.read('urbanFunction.xsd')
repo.parse_schema(
  content: xsd_content,
  location: File.dirname('urbanFunction.xsd')
)

# Resolve (builds type index)
repo.resolve

# Access the type index (internal)
type_index = repo.instance_variable_get(:@type_index)

# Query the index directly
type_info = type_index.find_by_namespace_and_name(
  'http://www.opengis.net/gml/3.2',
  'CodeType'
)

puts "Type: #{type_info[:type]}"
puts "Namespace: #{type_info[:namespace]}"
puts "Schema file: #{type_info[:schema_file]}"

# Get all types in namespace
gml_types = type_index.find_all_in_namespace(
  'http://www.opengis.net/gml/3.2'
)
puts "GML types count: #{gml_types.size}"

# Get statistics
stats = type_index.statistics
puts "Total types: #{stats[:total_types]}"
puts "Complex types: #{stats[:by_type][:complex_type]}"
puts "Simple types: #{stats[:by_type][:simple_type]}"
puts "Elements: #{stats[:by_type][:element]}"
----

=== Example 2: Type resolution with suggestions

[source,ruby]
----
# Try to find a misspelled type
result = repo.find_type('gml:CodeTypo')  # Wrong spelling

unless result.found?
  puts "Type not found: #{result.local_name}"

  # Get suggestions from index
  type_index = repo.instance_variable_get(:@type_index)
  suggestions = type_index.suggest_similar(
    'http://www.opengis.net/gml/3.2',
    'CodeTypo',
    limit: 5
  )

  if suggestions.any?
    puts "Did you mean one of these?"
    suggestions.each { |s| puts "  - #{s}" }
  end
end

# Output:
# Type not found: CodeTypo
# Did you mean one of these?
#   - CodeType
#   - CodeWithAuthorityType
#   - CodeOrNilReasonListType
----

=== Example 3: Indexing performance measurement

[source,ruby]
----
require 'benchmark'

repo = Lutaml::Xsd::SchemaRepository.new
repo.configure_namespace(prefix: 'gml', uri: 'http://www.opengis.net/gml/3.2')

# Measure parsing + indexing time
parse_time = Benchmark.realtime do
  xsd_content = File.read('large_schema.xsd')
  repo.parse_schema(content: xsd_content, location: '.')
  repo.resolve  # Builds index
end

# Measure lookup time
type_index = repo.instance_variable_get(:@type_index)

lookup_time = Benchmark.realtime do
  1000.times do
    type_index.find_by_namespace_and_name(
      'http://www.opengis.net/gml/3.2',
      'CodeType'
    )
  end
end

puts "Parse + index time: #{(parse_time * 1000).round(2)}ms"
puts "1000 lookups time: #{(lookup_time * 1000).round(2)}ms"
puts "Average lookup: #{(lookup_time / 1000 * 1000000).round(2)}µs"

# Example output:
# Parse + index time: 5234.56ms
# 1000 lookups time: 2.34ms
# Average lookup: 2.34µs
----

== Performance characteristics

=== Time complexity

* **Build index**: O(n) where n = total number of type definitions
* **Direct lookup**: O(1) hash lookup by Clark key
* **Namespace lookup**: O(1) for building key + O(1) for hash lookup
* **Find all in namespace**: O(n) where n = total types (filters entire index)
* **Suggest similar**: O(m) where m = types in namespace

=== Space complexity

* **Memory per type**: ~200-300 bytes (hash entry + type info)
* **Total memory**: ~500KB - 1MB for typical schemas (2000-3000 types)
* **Serialized size**: Depends on format
  * Marshal: ~100KB - 500KB (most compact)
  * JSON: ~200KB - 1MB (moderate)
  * YAML: ~300KB - 1.5MB (largest)

=== Indexing performance

.Indexing performance by schema size
|===
|Schema Size |Type Count |Index Time |Memory

|Small (GML subset)
|~50 types
|~10ms
|~15KB

|Medium (CityGML)
|~500 types
|~100ms
|~150KB

|Large (i-UR with deps)
|~2800 types
|~500ms
|~800KB

|Very Large (ISO/TC 211)
|~5000 types
|~1000ms
|~1.5MB
|===

=== Lookup performance

All lookups are O(1) regardless of index size:

* Direct lookup: ~1-3 microseconds
* Namespace + name lookup: ~2-5 microseconds
* 1000 lookups: ~2-5 milliseconds

This makes the index suitable for high-frequency queries in code generators and validation tools.

== See also

* link:ARCHITECTURE[System Architecture]
* link:PACKAGE_INTERNALS[LXR Package Internals]
* link:../core-concepts/TYPE_RESOLUTION[Type Resolution]
* link:index[Architecture Index]