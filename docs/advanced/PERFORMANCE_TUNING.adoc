---
layout: default
title: Performance tuning
nav_order: 1
parent: Advanced
---
= Performance tuning
:toc:
:toclevels: 3

== Purpose

This guide provides optimization strategies for achieving maximum performance with Lutaml::XSD. Learn how to choose the right package configuration, optimize memory usage, improve query performance, and benchmark your schema operations.

== General

Performance in Lutaml::XSD is controlled by three independent configuration axes that affect package size, loading time, and query performance. Understanding these trade-offs is essential for optimizing your application.

Key performance considerations:

* **Package configuration**: Choosing the right combination of modes
* **Memory vs speed**: Balancing resource usage with performance
* **Type index performance**: Optimizing qualified name lookups
* **Schema caching**: Reducing repeated parsing overhead
* **Benchmarking**: Measuring and improving performance

== Choosing optimal package configuration

=== Configuration axes

LXR packages use three independent configuration options that dramatically affect performance:

==== XSD bundling mode

Controls whether XSD files are bundled into the package:

`include_all` (recommended for production)::
* All XSD files embedded in package
* Schema location paths rewritten to be package-relative
* **Advantages**: Self-contained, no network access, portable
* **Trade-offs**: Larger file size

`allow_external`::
* Original schema location references preserved
* XSD files fetched from external sources
* **Advantages**: Smaller package size
* **Trade-offs**: Requires network/file access, slower

==== Resolution mode

Controls whether schemas are pre-serialized:

`resolved` (recommended for production)::
* All schemas pre-parsed and serialized
* Type index pre-built and included
* **Advantages**: Instant loading, immediate queries
* **Trade-offs**: Larger package size

`bare`::
* Only XSD files and minimal metadata included
* Schemas parsed on first use
* **Advantages**: Smaller package, faster creation
* **Trade-offs**: Slower initial loading

==== Serialization format

Controls how schemas are serialized (only relevant for `resolved` mode):

`marshal` (recommended for Ruby)::
* Ruby's native binary serialization
* **Advantages**: Fastest serialization/deserialization
* **Trade-offs**: Ruby-only, version-dependent

`json`::
* Cross-platform JSON format
* **Advantages**: Language-independent, human-readable
* **Trade-offs**: Slower than marshal, larger size

`yaml`::
* Human-readable YAML format
* **Advantages**: Best for debugging and inspection
* **Trade-offs**: Slowest performance, largest size

`parse`::
* No serialization, always parse XSD files
* **Advantages**: Always up-to-date with XSD changes
* **Trade-offs**: Slowest loading, no performance benefit

=== Performance comparison

.Package configuration performance characteristics
[example]
====
[source,ruby]
----
# Benchmark different package configurations
require 'lutaml/xsd'
require 'benchmark'

repo = Lutaml::Xsd::SchemaRepository.from_yaml_file('config.yml')
repo.parse.resolve

# Configuration 1: Optimal for production (RECOMMENDED)
Benchmark.measure do
  repo.to_package('pkg/prod.lxr',
                  xsd_mode: :include_all,
                  resolution_mode: :resolved,
                  serialization_format: :marshal)
end
# => Creation: ~200ms, Size: ~500KB, Load: ~50ms

# Configuration 2: Optimal for development
Benchmark.measure do
  repo.to_package('pkg/dev.lxr',
                  xsd_mode: :include_all,
                  resolution_mode: :bare,
                  serialization_format: :parse)
end
# => Creation: ~50ms, Size: ~100KB, Load: ~400ms

# Configuration 3: Cross-platform
Benchmark.measure do
  repo.to_package('pkg/portable.lxr',
                  xsd_mode: :include_all,
                  resolution_mode: :resolved,
                  serialization_format: :json)
end
# => Creation: ~300ms, Size: ~800KB, Load: ~150ms
----

Results (for a typical schema set with ~100 types):

|===
| Configuration | Creation | Size | Load Time | Use Case

| `include_all` + `resolved` + `marshal`
| Fast (200ms)
| Medium (500KB)
| **Fastest (50ms)**
| **Production (recommended)**

| `include_all` + `bare` + `parse`
| **Fastest (50ms)**
| **Smallest (100KB)**
| Slow (400ms)
| Development

| `include_all` + `resolved` + `json`
| Slow (300ms)
| Largest (800KB)
| Medium (150ms)
| Cross-platform

| `allow_external` + `resolved` + `marshal`
| Fast (180ms)
| Small (200KB)
| Fast (60ms)
| Requires external schemas
|===
====

=== Recommendation by use case

.Production applications
[example]
====
Use `include_all` + `resolved` + `marshal` for maximum runtime performance:

[source,bash]
----
lutaml-xsd package build config.yml \
  --xsd-mode include_all \
  --resolution-mode resolved \
  --serialization-format marshal \
  --output production.lxr
----

**Benefits**:

* Instant loading (~50ms for 100 types)
* Self-contained, no external dependencies
* Optimal query performance
* Package-once, deploy anywhere

**Trade-offs**:

* Larger package size
* Ruby Marshal format (Ruby-only)
====

.Development and testing
[example]
====
Use `include_all` + `bare` + `parse` for rapid iteration:

[source,bash]
----
lutaml-xsd package build config.yml \
  --xsd-mode include_all \
  --resolution-mode bare \
  --serialization-format parse \
  --output development.lxr
----

**Benefits**:

* Fast package creation
* Smallest file size
* Always reflects XSD changes
* Good for frequent schema modifications

**Trade-offs**:

* Slower loading (schemas parsed on use)
* No pre-built type index
====

.Cross-platform distribution
[example]
====
Use `include_all` + `resolved` + `json` for maximum portability:

[source,bash]
----
lutaml-xsd package build config.yml \
  --xsd-mode include_all \
  --resolution-mode resolved \
  --serialization-format json \
  --output portable.lxr
----

**Benefits**:

* Language-independent format
* Self-contained package
* Human-readable serialization
* Version-independent

**Trade-offs**:

* Larger package size
* Slower loading than marshal
====

== Memory vs speed trade-offs

=== Memory considerations

Different configurations have different memory footprints:

.Memory usage comparison
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

# Measure memory usage
def measure_memory
  GC.start
  before = `ps -o rss= -p #{Process.pid}`.to_i
  yield
  GC.start
  after = `ps -o rss= -p #{Process.pid}`.to_i
  (after - before) / 1024.0 # MB
end

# Resolved package: Pre-loaded schemas in memory
memory_resolved = measure_memory do
  repo = Lutaml::Xsd::SchemaRepository.from_package('resolved.lxr')
end
# => ~15-20 MB for 100 schemas

# Bare package: Parse on demand
memory_bare = measure_memory do
  repo = Lutaml::Xsd::SchemaRepository.from_package('bare.lxr')
  # Memory increases only when schemas are actually used
end
# => ~5 MB initially, grows as schemas are parsed
----

**Memory usage patterns**:

* **Resolved packages**: Higher initial memory, constant over time
* **Bare packages**: Lower initial memory, grows with usage
* **Type index**: ~100-200 KB per 1000 types
* **Parsed schemas**: ~50-100 KB per schema on average
====

=== Lazy loading strategies

.Implementing lazy loading for memory efficiency
[example]
====
[source,ruby]
----
# Strategy 1: Load package but parse schemas lazily
repo = Lutaml::Xsd::SchemaRepository.from_package('bare.lxr')
# Minimal memory at this point

# Schemas are parsed only when needed
result = repo.find_type('gml:CodeType')
# Now GML schemas are parsed and cached

# Strategy 2: Load specific namespaces on demand
repo = Lutaml::Xsd::SchemaRepository.from_yaml_file('config.yml')
repo.parse(lazy_load: true) # Only parse root schemas

# Import resolution happens on first type lookup
result = repo.find_type('gml:FeaturePropertyType')
# GML schemas parsed and imported now

# Strategy 3: Clear caches when memory is tight
repo.parse.resolve
# ... perform operations ...
Schema.clear_cache # Clear internal schema cache
# Note: Type index remains, but parsed schemas are released
----
====

== Benchmark results for serialization formats

=== Serialization performance

.Comparing serialization formats
[example]
====
[source,ruby]
----
require 'lutaml/xsd'
require 'benchmark'

repo = Lutaml::Xsd::SchemaRepository.from_yaml_file('config.yml')
repo.parse.resolve

formats = [:marshal, :json, :yaml]
results = {}

formats.each do |format|
  output = "pkg/benchmark_#{format}.lxr"

  # Measure package creation time
  creation_time = Benchmark.realtime do
    repo.to_package(output,
                    xsd_mode: :include_all,
                    resolution_mode: :resolved,
                    serialization_format: format)
  end

  # Measure package loading time
  load_time = Benchmark.realtime do
    Lutaml::Xsd::SchemaRepository.from_package(output)
  end

  file_size = File.size(output)

  results[format] = {
    creation: (creation_time * 1000).round(2),
    load: (load_time * 1000).round(2),
    size: (file_size / 1024.0).round(2)
  }
end

# Display results
puts "Format    | Creation (ms) | Load (ms) | Size (KB)"
puts "----------|---------------|-----------|----------"
results.each do |format, data|
  puts "%-9s | %13.2f | %9.2f | %8.2f" %
       [format, data[:creation], data[:load], data[:size]]
end
----

Typical results for 100 schemas with 500 types:

|===
| Format | Creation Time | Load Time | Package Size | Best For

| `marshal`
| 150-200ms
| **30-50ms**
| **400-500KB**
| **Production (Ruby apps)**

| `json`
| 250-350ms
| 100-150ms
| 700-900KB
| Cross-platform

| `yaml`
| 400-600ms
| 200-300ms
| 1-1.5MB
| Debugging/inspection

| `parse`
| **50-100ms**
| 350-500ms
| **80-120KB**
| Development
|===
====

== Type index performance

=== Understanding type index

The type index enables O(1) lookups for qualified names:

.Type index structure and performance
[example]
====
[source,ruby]
----
repo = Lutaml::Xsd::SchemaRepository.from_package('schemas.lxr')

# Type index is built during resolve()
# It maps Clark notation keys to type definitions
# Example: "{http://www.opengis.net/gml}CodeType" => definition

# O(1) lookup performance - constant time regardless of schema size
result = repo.find_type('gml:CodeType') # ~0.001ms
result = repo.find_type('ex:ComplexType') # ~0.001ms

# Even with 10,000 types, lookup time remains constant
stats = repo.statistics
puts "Total types: #{stats[:total_types]}"
# => Total types: 10000

Benchmark.realtime { repo.find_type('gml:CodeType') }
# => Still ~0.001ms
----

**Type index characteristics**:

* **Lookup time**: O(1) - constant regardless of number of types
* **Memory overhead**: ~200 bytes per type
* **Build time**: Linear with number of types (~0.1ms per 100 types)
* **Best practice**: Build once during package creation
====

=== Optimizing type queries

.Efficient type query patterns
[example]
====
[source,ruby]
----
# Good: Use qualified names with registered prefixes
repo.configure_namespace(prefix: 'gml', uri: 'http://www.opengis.net/gml')
result = repo.find_type('gml:CodeType') # Fast prefix lookup

# Good: Use Clark notation directly
result = repo.find_type('{http://www.opengis.net/gml}CodeType') # Direct lookup

# Avoid: Repeated namespace registration
# This is inefficient if done in a loop
1000.times do
  repo.configure_namespace(prefix: 'temp', uri: 'http://...')
  repo.find_type('temp:Type') # Registers namespace every time
end

# Better: Register once, query many times
repo.configure_namespace(prefix: 'temp', uri: 'http://...')
1000.times do
  repo.find_type('temp:Type') # Fast lookup
end

# Best: Use package with pre-configured namespaces
# Namespace mappings stored in package metadata
repo = Lutaml::Xsd::SchemaRepository.from_package('configured.lxr')
# All namespace prefixes already registered
1000.times { repo.find_type('gml:CodeType') } # No setup overhead
----
====

== Schema caching strategies

=== Built-in caching

Lutaml::XSD implements automatic schema caching:

.Understanding schema cache behavior
[example]
====
[source,ruby]
----
# Schema cache is global across all repositories
Schema.processed_schemas # => {} (empty initially)

# Parse first repository
repo1 = Lutaml::Xsd::SchemaRepository.from_yaml_file('config1.yml')
repo1.parse.resolve
Schema.processed_schemas.size # => 50 schemas cached

# Parse second repository that shares schemas
repo2 = Lutaml::Xsd::SchemaRepository.from_yaml_file('config2.yml')
repo2.parse.resolve
Schema.processed_schemas.size # => 75 (only 25 new schemas)

# Shared schemas are not re-parsed
# This saves significant time for common dependencies like GML, XLink

# Clear cache when needed (e.g., schema files changed)
Schema.clear_cache
Schema.processed_schemas.size # => 0
----

**Cache benefits**:

* Shared schemas parsed only once
* Significant speed-up for common dependencies
* Automatic cache management
* Thread-safe implementation
====

=== Package-level caching

.Using packages as persistent caches
[example]
====
[source,ruby]
----
# Strategy: Create packages for different schema sets
# and reuse them instead of re-parsing

# Initial setup (one-time cost)
['gml', 'citygml', 'iur'].each do |schema_set|
  repo = Lutaml::Xsd::SchemaRepository.from_yaml_file("#{schema_set}.yml")
  repo.parse.resolve
  repo.to_package("pkg/#{schema_set}.lxr",
                  xsd_mode: :include_all,
                  resolution_mode: :resolved,
                  serialization_format: :marshal)
end
# => Created 3 packages (one-time: ~1 second total)

# Runtime: Load pre-built packages (fast)
gml_repo = Lutaml::Xsd::SchemaRepository.from_package('pkg/gml.lxr')
citygml_repo = Lutaml::Xsd::SchemaRepository.from_package('pkg/citygml.lxr')
iur_repo = Lutaml::Xsd::SchemaRepository.from_package('pkg/iur.lxr')
# => All loaded in ~150ms total vs ~5 seconds to parse from XSD

# Use packages throughout application lifecycle
result = gml_repo.find_type('gml:CodeType')
----
====

== Best practices for large schema sets

=== Partitioning strategies

.Managing large schema collections
[example]
====
[source,ruby]
----
# Problem: Single package with 1000+ schemas
# - Slow to build
# - Large file size
# - Memory intensive

# Solution 1: Partition by namespace
# Create separate packages for each namespace family

# GML package (core dependencies)
gml_repo = Lutaml::Xsd::SchemaRepository.from_yaml_file('gml.yml')
gml_repo.to_package('pkg/gml-3.2.1.lxr')

# CityGML package (depends on GML)
citygml_repo = Lutaml::Xsd::SchemaRepository.from_yaml_file('citygml.yml')
citygml_repo.to_package('pkg/citygml-2.0.lxr')

# Application can load only what it needs
if needs_citygml?
  repo = Lutaml::Xsd::SchemaRepository.from_package('pkg/citygml-2.0.lxr')
else
  repo = Lutaml::Xsd::SchemaRepository.from_package('pkg/gml-3.2.1.lxr')
end

# Solution 2: Partition by feature
# Separate packages for different application features

feature_packages = {
  core: 'pkg/core-schemas.lxr',
  advanced: 'pkg/advanced-schemas.lxr',
  experimental: 'pkg/experimental-schemas.lxr'
}

# Load based on application configuration
active_features = [:core, :advanced]
active_features.each do |feature|
  repo = Lutaml::Xsd::SchemaRepository.from_package(feature_packages[feature])
  # Use repo for this feature
end
----
====

=== Incremental loading

.Loading schemas incrementally
[example]
====
[source,ruby]
----
# For very large schema sets, load incrementally

class IncrementalSchemaLoader
  def initialize
    @repos = {}
  end

  def load_namespace(namespace_prefix)
    return @repos[namespace_prefix] if @repos[namespace_prefix]

    package_path = "pkg/#{namespace_prefix}.lxr"
    @repos[namespace_prefix] =
      Lutaml::Xsd::SchemaRepository.from_package(package_path)
  end

  def find_type(qname)
    # Extract namespace prefix
    prefix = qname.split(':').first

    # Load namespace package if not already loaded
    repo = load_namespace(prefix)
    repo.find_type(qname)
  end
end

# Usage
loader = IncrementalSchemaLoader.new
result = loader.find_type('gml:CodeType') # Loads GML package
result = loader.find_type('citygml:Building') # Loads CityGML package
----
====

== Performance monitoring

=== Measuring package operations

.Benchmarking package creation and loading
[example]
====
[source,ruby]
----
require 'benchmark'
require 'lutaml/xsd'

def benchmark_package_lifecycle(config_file)
  results = {}

  # Measure parsing
  results[:parse] = Benchmark.realtime do
    @repo = Lutaml::Xsd::SchemaRepository.from_yaml_file(config_file)
    @repo.parse.resolve
  end

  # Measure package creation
  results[:create] = Benchmark.realtime do
    @repo.to_package('benchmark.lxr',
                     xsd_mode: :include_all,
                     resolution_mode: :resolved,
                     serialization_format: :marshal)
  end

  # Measure package loading
  results[:load] = Benchmark.realtime do
    Lutaml::Xsd::SchemaRepository.from_package('benchmark.lxr')
  end

  # Measure type queries
  loaded_repo = Lutaml::Xsd::SchemaRepository.from_package('benchmark.lxr')
  test_types = ['gml:CodeType', 'gml:FeaturePropertyType', 'gml:MeasureType']

  results[:query] = Benchmark.realtime do
    1000.times do
      test_types.each { |type| loaded_repo.find_type(type) }
    end
  end / 3000.0 # Average per query

  results[:package_size] = File.size('benchmark.lxr')
  results[:stats] = @repo.statistics

  results
end

results = benchmark_package_lifecycle('config.yml')

puts "Performance Report"
puts "=" * 50
puts "Parse time:       #{(results[:parse] * 1000).round(2)}ms"
puts "Create time:      #{(results[:create] * 1000).round(2)}ms"
puts "Load time:        #{(results[:load] * 1000).round(2)}ms"
puts "Query time:       #{(results[:query] * 1000000).round(2)}Î¼s"
puts "Package size:     #{(results[:package_size] / 1024.0).round(2)} KB"
puts "Total schemas:    #{results[:stats][:total_schemas]}"
puts "Total types:      #{results[:stats][:total_types]}"
----
====

=== Production monitoring

.Monitoring schema operations in production
[example]
====
[source,ruby]
----
# Add instrumentation for production monitoring

class MonitoredSchemaRepository < Lutaml::Xsd::SchemaRepository
  def find_type(qname)
    start_time = Time.now
    result = super(qname)
    duration = Time.now - start_time

    # Log slow queries
    if duration > 0.1 # 100ms threshold
      warn "Slow type query: #{qname} took #{duration}s"
    end

    # Metrics collection (e.g., StatsD, Prometheus)
    # Metrics.timing('schema.type_query', duration * 1000)
    # Metrics.increment('schema.type_query.count')
    # Metrics.increment("schema.type_query.#{result.resolved? ? 'success' : 'failure'}")

    result
  end
end

# Usage
repo = MonitoredSchemaRepository.from_package('production.lxr')
result = repo.find_type('gml:CodeType')
# Logs and metrics automatically recorded
----
====

=== Performance testing

.Automated performance regression tests
[example]
====
[source,ruby]
----
# spec/performance/schema_performance_spec.rb
require 'benchmark'

RSpec.describe 'Schema Performance' do
  let(:repo) do
    Lutaml::Xsd::SchemaRepository.from_package('spec/fixtures/test.lxr')
  end

  it 'loads package within threshold' do
    load_time = Benchmark.realtime do
      Lutaml::Xsd::SchemaRepository.from_package('spec/fixtures/test.lxr')
    end

    expect(load_time).to be < 0.1 # 100ms threshold
  end

  it 'performs type queries within threshold' do
    query_time = Benchmark.realtime do
      100.times { repo.find_type('gml:CodeType') }
    end

    avg_time = query_time / 100.0
    expect(avg_time).to be < 0.001 # 1ms per query
  end

  it 'maintains memory usage within threshold' do
    GC.start
    before = `ps -o rss= -p #{Process.pid}`.to_i

    repo = Lutaml::Xsd::SchemaRepository.from_package('spec/fixtures/test.lxr')
    100.times { repo.find_type('gml:CodeType') }

    GC.start
    after = `ps -o rss= -p #{Process.pid}`.to_i
    memory_increase = (after - before) / 1024.0 # MB

    expect(memory_increase).to be < 50 # 50MB threshold
  end
end
----
====

== See also

* link:../guides/CREATING_PACKAGES[Creating packages] - Package creation guide
* link:../core-concepts/LXR_PACKAGES[LXR packages] - Package concepts
* link:DEBUGGING[Debugging] - Troubleshooting performance issues
* link:../reference/CLI[CLI reference] - Command-line options