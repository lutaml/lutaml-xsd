= Lutaml::Xsd

https://github.com/lutaml/lutaml-xsd[image:https://img.shields.io/github/stars/lutaml/lutaml-xsd.svg?style=social[GitHub Stars]]
https://github.com/lutaml/lutaml-xsd[image:https://img.shields.io/github/forks/lutaml/lutaml-xsd.svg?style=social[GitHub Forks]]
image:https://img.shields.io/gem/v/lutaml-xsd.svg[RubyGems Version]
image:https://img.shields.io/github/license/lutaml/lutaml-xsd.svg[License]
image:https://github.com/lutaml/lutaml-xsd/actions/workflows/rake.yml/badge.svg["Build", link="https://github.com/lutaml/lutaml-xsd/actions/workflows/rake.yml"]

== Purpose

Lutaml::Xsd is a Ruby gem designed to parse and manipulate XML Schema Definition
(XSD) files. It provides a robust framework for handling XSD elements,
attributes, complex types, and all other XSD constructs, allowing users to
programmatically work with XML schemas.

NOTE: For UML-to-XSD mapping and YAML documentation generation (including
ShapeChange integration), see the
https://github.com/lutaml/lutaml-klin[lutaml-klin] gem which orchestrates both
https://github.com/lutaml/lutaml[lutaml] (for UML parsing) and lutaml-xsd (for
XSD schema operations).

The `lutaml-xsd` gem provides a Ruby library for working with XSD schemas,
allowing users to parse XSD files into Ruby objects, manipulate schema
structures, and serialize them back to XML. It is built on top of the
`lutaml-model` serialization framework, which provides a flexible and extensible
way to define data models.

This library is particularly useful for developers working with XML-based
standards, schema transformation tools, code generators, and XML validation
systems.

== Origin

The name "LutaML" is pronounced as "Looh-tah-mel".

The name "LutaML" comes from the Latin word for clay, "Lutum", and "ML" for
"Markup Language". Just as clay can be molded and modeled into beautiful and
practical end products, the Lutaml::Model gem is used for data modeling,
allowing you to shape and structure your data into useful forms.

== Features

* <<spa-documentation,SPA documentation generation>> - Modern, responsive,
  interactive HTML documentation with schema navigation and search
  - Single-file and API modes
  - Entrypoint prioritization in sidebar
  - Schema detail views with elements/types/attributes tables
  - Hash-based navigation with browser back/forward support
  - Dark mode with automatic theme detection
* <<schema-validation,XSD schema validation>> with automatic version detection
  - Pre-parsing validation to ensure valid XSD schema documents
  - Automatic detection of XSD 1.0 vs 1.1 features
  - Support for both W3C XML Schema 1.0 and 1.1 standards
  - Comprehensive error messages for invalid schemas
* <<cli-commands,Command-line interface>>
  - `pkg` commands for package inspection
  - `xml` commands for XML validation
  - `build` commands for package creation
  - `doc` commands for documentation generation
* <<lxr-packages,LXR (LutaML XSD Repository) packages>> for distributable,
  pre-indexed schema collections
* <<parsing-xsd,XSD file parsing>> with full schema structure support
* <<schema-representation,Schema object representation>> with all XSD
  components
* <<include-import,Include and import handling>> with location resolution
* <<schema-mappings,Schema location mappings>> for local/remote schema
  redirection
* <<schema-repository,SchemaRepository>> for namespace-aware type resolution
  across multiple schemas
* Multiple serialization formats (marshal, json, yaml, parse)
* Flexible package configuration with three independent axes (XSD mode,
  resolution mode, serialization format)
* Interactive package building from XSD files
* Instant schema loading with pre-serialized schemas
* Pre-built type indexes for fast qualified name lookups
* <<serialization,XML serialization>> with round-trip compatibility
* <<liquid-methods,Liquid template methods>> for schema introspection and
  documentation
* Integration with the `lutaml-model` serialization framework
* Support for complex types, simple types, elements, attributes, and groups
* Pattern-based schema location mapping with regular expressions
* URL fetching for remote schemas with local caching support

[[spa-documentation]]
== XSD documentation generation

=== General

Lutaml::Xsd can generate modern, responsive, single-page application (SPA)
documentation for your XML schemas. The generated documentation provides an
interactive, user-friendly interface for exploring schema structures, types,
elements, and relationships.

A LXR package is required as input to generate the documentation.

=== Quick start

Generate single-file documentation:

[source,bash]
----
# Generate standalone HTML file with semantic URLs
lutaml-xsd doc spa your_package.lxr --mode single_file --output docs.html

# Generate with custom title
lutaml-xsd doc spa schemas.lxr --mode single_file --output docs.html \
  --title "My Schema Documentation"
----

.Generated SPA includes:
* Schema navigation with entrypoints prioritized
* Element and type detail views
* XML Instance Representation for each component
* Clickable cross-references throughout
* xs3p-quality documentation

Generate API-mode documentation with server:

[source,bash]
----
# Generate API-based SPA with Sinatra server
lutaml-xsd doc spa your_package.lxr --mode api --output-dir docs/

# Start the server
cd docs/
bundle install
bundle exec rackup

# Access at http://localhost:9292
----

=== Navigation and Linking

The generated SPA provides comprehensive navigation:

**Semantic URLs:**
All components have bookmarkable, human-readable URLs:

[source]
----
#/schemas/gml-base                              # Schema overview
#/schemas/gml-base/elements/abstract-gml        # Element detail
#/schemas/gml-base/types/type-abstract-gml-type # Complex type detail
----

**Cross-references:**
All type and element references are clickable links:

* Element type â†’ type detail page
* Base type â†’ parent type page
* Schema name â†’ schema overview
* Type columns in tables â†’ type details
* Element tags in XML instances â†’ element details

**XML Instance Examples:**
Each element and type shows an XML Instance Representation demonstrating usage:

[source,xml]
----
<Element
 attribute="type" [0..1]
>
  Start Sequence [1..1]
    <childElement> ... </childElement> [0..*]
  End Sequence
</Element> [1..1]
----

With xs3p-inspired color coding:
* Blue - Element tags
* Green - Attribute names
* Red - Type values
* Gray - Cardinality and model groups

=== Output modes

==== Single-file mode

Generates a standalone HTML file with all assets (CSS, JavaScript, data) embedded.
Perfect for:

* Email attachments or file sharing
* Offline documentation
* Simple deployment (just one file)
* Version control (single file to track)

[source,bash]
----
lutaml-xsd generate-spa schemas.lxr --mode single_file --output schema-docs.html
----

==== Multi-file mode

Generates a documentation site with separate resource files. Perfect for:

* Web hosting (better caching)
* Larger schema sets (faster loading)
* Professional deployment
* CDN optimization

[source,bash]
----
lutaml-xsd generate-spa schemas.lxr --mode multi_file --output-dir ./docs
----

=== Configuration

The SPA generator is fully configurable via YAML files in `config/spa/`:

* `config/spa/ui_theme.yml` - Colors, typography, layout customization
* `config/spa/features.yml` - Feature toggles and behavior settings
* `config/spa/templates.yml` - Template structure and components

.Example: Custom configuration
[example]
====
[source,bash]
----
# Generate with custom configuration
lutaml-xsd generate-spa schemas.lxr \
  --mode single_file \
  --output custom-docs.html \
  --config config/my-custom-spa-config.yml \
  --title "Custom Schema Docs"
----
====

=== Documentation

For comprehensive documentation on SPA generation, see:

* link:docs/SPA_GUIDE.adoc[SPA User Guide] - Complete usage guide
* link:docs/SPA_CONFIGURATION.adoc[Configuration Reference] - All configuration options
* link:docs/SPA_DEPLOYMENT.adoc[Deployment Guide] - Hosting and CI/CD integration
* link:docs/SPA_ARCHITECTURE.adoc[Architecture Documentation] - Design and extension guide

[[schema-validation]]
== XSD schema validation

=== General

Lutaml::Xsd provides pre-parsing validation of XSD schema documents to ensure
they are well-formed and compliant with XML Schema standards before attempting
to parse them. This helps catch errors early and provides clear, actionable
error messages.

The schema validator supports both W3C XML Schema 1.0 and 1.1 standards, with
automatic detection of version-specific features. Validation is automatically
enabled when parsing schemas via [`Lutaml::Xsd.parse()`](lib/lutaml/xsd.rb:47) but can be disabled
if needed.

=== Validation checks

The schema validator performs these checks:

* **XML syntax correctness**: Ensures the document is well-formed XML
* **XML Schema namespace**: Verifies the schema uses the correct W3C namespace
  (`http://www.w3.org/2001/XMLSchema`)
* **Version compliance**: Detects XSD 1.1 features (like `xs:assert`) and
  ensures they're only used with XSD 1.1 validation
* **Root element validation**: Confirms the document root is `xs:schema`

=== Automatic version detection

The validator can automatically detect whether a schema uses XSD 1.0 or 1.1
features:

.Automatic XSD version detection
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

xsd_content = File.read('schema.xsd')

# Detect version automatically
version = Lutaml::Xsd::SchemaValidator.detect_version(xsd_content)
puts "Detected XSD version: #{version}"  # "1.0" or "1.1"

# Use detected version for validation
validator = Lutaml::Xsd::SchemaValidator.new(version: version)
validator.validate(xsd_content)  # Returns true or raises error
----
====

XSD 1.1 features that trigger automatic detection:

* `xs:assert` elements (CTA - Complex Type Assertions)
* `xs:assertion` elements
* `xs:openContent` elements
* `xs:override` elements
* `vc:minVersion` attributes

=== Using schema validation

==== Automatic validation (recommended)

Schema validation is automatically enabled when using [`Lutaml::Xsd.parse()`](lib/lutaml/xsd.rb:47):

.Automatic schema validation during parsing
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

xsd_content = File.read('schema.xsd')

# Schema is automatically validated before parsing
schema = Lutaml::Xsd.parse(xsd_content)

# If validation fails, SchemaValidationError is raised
begin
  invalid_content = '<root>Not a schema</root>'
  schema = Lutaml::Xsd.parse(invalid_content)
rescue Lutaml::Xsd::SchemaValidationError => e
  puts "Invalid schema: #{e.message}"
  # Error: Not a valid XSD schema document
end
----
====

==== Disabling automatic validation

To skip schema validation (not recommended):

.Disabling schema validation
[example]
====
[source,ruby]
----
# Parse without schema validation
schema = Lutaml::Xsd.parse(xsd_content, validate_schema: false)

# Note: This may lead to parsing errors if the schema is malformed
----
====

==== Manual validation

For standalone schema validation without parsing:

.Manual schema validation
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

xsd_content = File.read('schema.xsd')

# Create validator (default XSD 1.0)
validator = Lutaml::Xsd::SchemaValidator.new

# Validate the schema
begin
  validator.validate(xsd_content)
  puts "Schema is valid!"
rescue Lutaml::Xsd::SchemaValidationError => e
  puts "Validation failed: #{e.message}"
end

# Validate against XSD 1.1
validator_1_1 = Lutaml::Xsd::SchemaValidator.new(version: "1.1")
validator_1_1.validate(xsd_content)
----
====

==== CLI validation

Validate XSD schema files from the command line:

.Validating schemas with CLI
[example]
====
[source,bash]
----
# Validate a single schema
lutaml-xsd validate-schema schema.xsd

# Validate multiple schemas
lutaml-xsd validate-schema schema1.xsd schema2.xsd schema3.xsd

# Validate with glob patterns
lutaml-xsd validate-schema schemas/*.xsd

# Validate against XSD 1.1
lutaml-xsd validate-schema schema.xsd --version 1.1

# Verbose output with version detection
lutaml-xsd validate-schema schema.xsd --verbose

# JSON output for CI/CD integration
lutaml-xsd validate-schema schema.xsd --format json

# YAML output for CI/CD integration
lutaml-xsd validate-schema schema.xsd --format yaml
----

Text output (default):

[source]
----
âœ“ schema.xsd

Summary:
  Total: 1
  Valid: 1
  Invalid: 0
----

With verbose mode:

[source]
----
âœ“ schema.xsd (XSD 1.0)

Summary:
  Total: 1
  Valid: 1
  Invalid: 0
----

JSON output for CI/CD:

[source,json]
----
{
  "summary": {
    "total": 2,
    "valid": 1,
    "invalid": 1
  },
  "results": [
    {
      "file": "valid_schema.xsd",
      "valid": true,
      "detected_version": "1.0"
    },
    {
      "file": "invalid_schema.xsd",
      "valid": false,
      "error": "Not a valid XSD schema: root element must be 'schema', found 'root'"
    }
  ]
}
----

YAML output for CI/CD:

[source,yaml]
----
summary:
  total: 2
  valid: 1
  invalid: 1
results:
- file: valid_schema.xsd
  valid: true
  detected_version: '1.0'
- file: invalid_schema.xsd
  valid: false
  error: "Not a valid XSD schema: root element must be 'schema', found 'root'"
----

The `--format` option supports three formats:

* `text` (default): Human-readable output with checkmarks and summary
* `json`: Machine-readable JSON format for CI/CD pipelines
* `yaml`: Machine-readable YAML format for CI/CD pipelines

Both JSON and YAML formats include complete validation results with file paths, validity status, error messages, and detected versions (when `--verbose` is used).
====

=== Validation errors

The validator provides clear error messages with context:

.Common validation errors
[example]
====
[source,bash]
----
# Missing XML Schema namespace
$ lutaml-xsd validate-schema bad-schema.xsd

âœ— bad-schema.xsd
  Error: Schema element must be in the XML Schema namespace
  (http://www.w3.org/2001/XMLSchema)

# Using XSD 1.1 features with 1.0 validator
$ lutaml-xsd validate-schema schema-with-assert.xsd --version 1.0

âœ— schema-with-assert.xsd
  Error: XSD 1.1 features detected (xs:assert) but validating as XSD 1.0

# Malformed XML
$ lutaml-xsd validate-schema malformed.xsd

âœ— malformed.xsd
  Error: Invalid XML syntax: Missing closing tag
----
====

=== See also

* link:docs/CLI.adoc[Complete CLI reference]
* link:docs/RUBY_API.adoc[Ruby API documentation]

[[cli-commands]]
== Command-line interface

=== General

The `lutaml-xsd` command-line interface provides powerful tools for inspecting,
querying, and managing XSD schema packages. Commands are organized into four
MECE (Mutually Exclusive, Collectively Exhaustive) categories based on what
they operate on.

=== Command structure

The CLI follows this structure:

[source,bash]
----
lutaml-xsd <CATEGORY> <command> [arguments] [options]
----

Where `<CATEGORY>` is one of:

`pkg`:: Package inspection commands (operate on `.lxr` files)
`xml`:: XML validation commands (operate on `.xml` files)
`build`:: Package creation commands (operate on `.yml` configs)
`doc`:: Documentation generation commands (operate on `.lxr` files)

This structure ensures:

* **Mutually exclusive**: Each command belongs to exactly one category
* **Collectively exhaustive**: All operations are covered
* **Clear separation**: Commands grouped by input type, not feature

=== PKG commands (package inspection)

All commands for inspecting and querying LXR packages.

==== Listing schemas

List all schemas in a package with namespace URIs.

[source,bash]
----
# List all schemas
lutaml-xsd pkg ls <package.lxr>

# Detailed listing (like ls -l)
lutaml-xsd pkg ls --long <package.lxr>

# Tree view of package contents
lutaml-xsd pkg tree <package.lxr>

# Full package details
lutaml-xsd pkg inspect <package.lxr>
----

.Listing schemas with namespace URIs
[example]
====
[source,bash]
----
$ lutaml-xsd pkg ls pkg/urban_function_repository.lxr

SCHEMAS (119 total)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Namespace URI                           â”‚ File              â”‚ Elements â”‚ Types â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ https://www.geospatial.jp/iur/urf/3.2   â”‚ urbanFunction.xsd â”‚      245 â”‚ 1,164 â”‚
â”‚ http://www.w3.org/1999/xlink            â”‚ xlinks.xsd        â”‚       12 â”‚    25 â”‚
â”‚ http://www.opengis.net/gml/3.2          â”‚ basicTypes.xsd    â”‚       89 â”‚   234 â”‚
â”‚ ... (ALL 119 schemas shown)             â”‚                   â”‚          â”‚       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

â­ 1 entrypoint, 118 dependencies
----

The output uses the `table-tennis` gem for beautiful terminal tables with:

* Auto-theming based on terminal background (light/dark)
* Zebra striping for readability
* Proper column alignment
* Unicode box-drawing characters

All listings show **complete output** with no truncation.
====

==== Entrypoints and dependencies

Show which XSD files are entry points and their dependency tree.

[source,bash]
----
# List entrypoints and dependencies
lutaml-xsd pkg entrypoints <package.lxr>

# Show dependency tree from entrypoints
lutaml-xsd pkg entrypoints --tree <package.lxr>

# Limit tree depth
lutaml-xsd pkg entrypoints --tree --depth 3 <package.lxr>
----

.Viewing entrypoint dependency tree
[example]
====
[source,bash]
----
$ lutaml-xsd pkg entrypoints --tree pkg/urban_function_repository.lxr

ENTRYPOINTS & DEPENDENCY TREE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“„ urbanFunction.xsd â­ ENTRYPOINT
   URI: https://www.geospatial.jp/iur/urf/3.2
   Types: 1,164 | Elements: 245

   â”œâ”€â”€ import â†’ xlinks.xsd
   â”‚   URI: http://www.w3.org/1999/xlink
   â”‚   â””â”€â”€ (no dependencies)
   â”‚
   â”œâ”€â”€ import â†’ uro/UrbanObject.xsd
   â”‚   URI: https://www.geospatial.jp/iur/uro/3.2
   â”‚   â”œâ”€â”€ import â†’ gml/Feature.xsd
   â”‚   â”‚   URI: http://www.opengis.net/gml/3.2
   â”‚   â”‚   â”œâ”€â”€ include â†’ gmlBase.xsd
   â”‚   â”‚   â”‚   â”œâ”€â”€ include â†’ basicTypes.xsd
   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ include â†’ dictionary.xsd
   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ include â†’ gmlBase.xsd (â†» circular)
   â”‚   â”‚   â”‚   â””â”€â”€ include â†’ feature.xsd
   â”‚   â”‚   â”‚       â””â”€â”€ ... (all shown)
   â”‚   â”‚   â””â”€â”€ import â†’ core/CityModel.xsd
   â”‚   â”‚       URI: http://www.opengis.net/citygml/3.0
   â”‚   â”‚       â””â”€â”€ ... (all shown)
   â”‚   â””â”€â”€ import â†’ gml/AbstractGML.xsd
   â”‚       URI: http://www.opengis.net/gml/3.2
   â”‚       â””â”€â”€ (resolved above)
   â”‚
   â””â”€â”€ import â†’ gml/AbstractGML.xsd
       URI: http://www.opengis.net/gml/3.2
       â””â”€â”€ (resolved above)

Summary: 1 entrypoint | 118 dependencies | 3 circular â†»
----

The tree view:

* Shows complete import/include hierarchy
* Displays namespace URI for each schema
* Identifies circular dependencies
* Never truncates output
====

==== Type definition display

Show the actual XSD definition for types, elements, and attributes.

[source,bash]
----
# Show type XSD definition
lutaml-xsd pkg type-def <qname> <package.lxr>

# Show element XSD definition
lutaml-xsd pkg element-def <qname> <package.lxr>

# Show attribute XSD definition
lutaml-xsd pkg attribute-def <qname> <package.lxr>
----

.Displaying type definitions with XSD source
[example]
====
[source,bash]
----
$ lutaml-xsd pkg type-def "gml:PointType" gml.lxr

TYPE DEFINITION: gml:PointType
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Namespace: http://www.opengis.net/gml/3.2
File: geometryBasic0d1d.xsd
Line: 156
Category: Complex Type

XSD DEFINITION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<xs:complexType name="PointType">
  <xs:annotation>
    <xs:documentation>
      A Point is defined by a single coordinate tuple.
    </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
    <xs:extension base="gml:AbstractGeometricPrimitiveType">
      <xs:sequence>
        <xs:choice>
          <xs:element ref="gml:pos"/>
          <xs:element ref="gml:coordinates"/>
        </xs:choice>
      </xs:sequence>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>

INHERITS FROM:
  gml:AbstractGeometricPrimitiveType
    â””â”€ gml:AbstractGeometryType
       â””â”€ gml:AbstractGMLType

USED BY (15 types):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Type                       â”‚ Location        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ gml:PointPropertyType      â”‚ geometry.xsd:89 â”‚
â”‚ gml:MultiPointType         â”‚ geometry.xsd:234â”‚
â”‚ ... (all 15 shown)         â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

This command:

* Shows the exact XSD source code
* Displays file location with line number
* Shows inheritance hierarchy
* Lists all types that use this definition
* Always includes namespace URIs
====

==== Namespace filtering

Show all types, elements, or attributes in a specific namespace.

[source,bash]
----
# Show all types in a namespace
lutaml-xsd pkg namespace-types <uri-or-prefix> <package.lxr>

# Show all elements in a namespace
lutaml-xsd pkg namespace-elements <uri-or-prefix> <package.lxr>

# Show all attributes in a namespace
lutaml-xsd pkg namespace-attributes <uri-or-prefix> <package.lxr>
----

.Filtering types by namespace
[example]
====
[source,bash]
----
$ lutaml-xsd pkg namespace-types "urf" pkg/urban_function_repository.lxr

NAMESPACE: https://www.geospatial.jp/iur/urf/3.2 (prefix: urf)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPLEX TYPES (892)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Type Name                        â”‚ Elements â”‚ Attributes â”‚ Base Type    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ urf:UrbanFacilityType            â”‚       12 â”‚          3 â”‚ gml:Feature  â”‚
â”‚ urf:PublicTransportationType     â”‚        8 â”‚          2 â”‚ gml:Feature  â”‚
â”‚ ... (ALL 892 types shown)        â”‚          â”‚            â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SIMPLE TYPES (25)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Type Name                        â”‚ Base Type     â”‚ Restriction â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ urf:StatusType                   â”‚ xs:string     â”‚ enumeration â”‚
â”‚ urf:CategoryType                 â”‚ xs:string     â”‚ enumeration â”‚
â”‚ ... (ALL 25 shown)               â”‚               â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Use 'lutaml-xsd pkg type-def <qname> <package>' for full XSD definition
----

This is useful for:

* Understanding what's defined in each namespace
* Finding all types from a specific schema standard
* Comparing type coverage across namespaces
====

==== Type queries

Query and explore types within a package.

[source,bash]
----
# Find a specific type
lutaml-xsd pkg type <qname> <package.lxr>

# Show type dependencies
lutaml-xsd pkg type-deps <qname> <package.lxr>

# Show what depends on a type
lutaml-xsd pkg type-uses <qname> <package.lxr>

# Show type hierarchy
lutaml-xsd pkg type-hierarchy <qname> <package.lxr>

# List all types
lutaml-xsd pkg type-list <package.lxr>
----

==== Package statistics

Display package statistics and metrics.

[source,bash]
----
# Show package statistics
lutaml-xsd pkg stats <package.lxr>

# Coverage analysis from entry points
lutaml-xsd pkg coverage <package.lxr> --entry <schema-name>
----

=== XML commands (XML validation)

Validate XML instance files against XSD schemas.

[source,bash]
----
# Validate against a schema file
lutaml-xsd xml validate <file.xml> --schema <file.xsd>

# Validate against a package
lutaml-xsd xml validate <file.xml> --package <file.lxr>

# Batch validation
lutaml-xsd xml validate-batch <directory/> --package <file.lxr>
----

=== BUILD commands (package creation)

Create LXR packages from configurations.

[source,bash]
----
# Build from YAML config
lutaml-xsd build from-config <config.yml>

# Interactive initialization
lutaml-xsd build init <entrypoint.xsd>

# Quick build + validate + stats
lutaml-xsd build quick <config.yml>

# Build with smart caching
lutaml-xsd build auto <config.yml>
----

==== Build warnings

When building packages, individual warnings are displayed for any unresolved
references.

.Package build with warnings
[example]
====
[source,bash]
----
$ lutaml-xsd build from-config config.yml

Building package from config...

âœ“ Parsing urbanFunction.xsd
âœ“ Resolving imports: xlinks.xsd
âš  Warning: Reference not resolved in UrbanObject.xsd:234
    Type "core:BuildingType" not found
    Namespace: http://www.opengis.net/citygml/3.0
    Hint: Add core CityGML schemas to dependencies

âœ“ Resolving imports: gml/Feature.xsd

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Status: âœ“ Package created with 1 warning(s)
Action: Review warnings and update config if needed
----

Each warning shows:

* Location (file and line number)
* Unresolved reference name
* Namespace URI
* Actionable hint for resolution
====

=== DOC commands (documentation generation)

Generate documentation from LXR packages.

[source,bash]
----
# Generate SPA documentation (single-file)
lutaml-xsd doc spa <package.lxr> --mode single_file --output docs.html

# Generate SPA with API mode (multi-file with server)
lutaml-xsd doc spa <package.lxr> --mode api --output-dir docs/

# Generate markdown documentation
lutaml-xsd doc markdown <package.lxr> --output-dir docs/
----

==== API mode documentation

The API mode generates a complete Sinatra-based server with separate frontend
and JSON API.

.Generating API-mode SPA
[example]
====
[source,bash]
----
# Generate with API mode
$ lutaml-xsd doc spa pkg/urban_function_repository.lxr \
    --mode api \
    --output-dir tmp/api_docs

SPA Documentation Generated Successfully
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Output files (6 total):
  tmp/api_docs/public/index.html
  tmp/api_docs/data/schemas.json
  tmp/api_docs/lib/app.rb
  tmp/api_docs/config.ru
  tmp/api_docs/Gemfile
  tmp/api_docs/README.md

âœ“ Generation complete

# Install dependencies and start server
$ cd tmp/api_docs
$ bundle install
$ bundle exec rackup

# Access at http://localhost:9292
----

The API mode provides:

* **Separate frontend and backend**: HTML/JS frontend fetches data via API
* **RESTful endpoints**: `/api/schemas`, `/api/schemas/:id`, `/api/health`
* **CORS enabled**: Can be used by external applications
* **Production ready**: Sinatra server with proper error handling

API endpoints:

* `GET /` - Serves the frontend HTML
* `GET /api/schemas` - Returns all schema data as JSON
* `GET /api/schemas/:id` - Returns specific schema by ID
* `GET /api/health` - Health check endpoint
====

=== Table formatting

All CLI table output uses the `table-tennis` gem for beautiful, auto-themed
terminal tables.

Features:

* **Auto-theming**: Detects terminal background (light/dark)
* **Zebra stripes**: Alternating row colors for readability
* **Color scales**: Numeric columns use color gradients
* **Row numbers**: Optional line numbering
* **Search highlighting**: Highlights search terms in output

.Table display features
[example]
====
[source,bash]
----
# Tables automatically adapt to your terminal theme
$ lutaml-xsd pkg ls package.lxr

# In dark terminal: light text on dark background
# In light terminal: dark text on light background

# Zebra stripes improve readability for long lists
# Color scales visualize numeric columns (more = redder/greener)
----
====


== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem 'lutaml-xsd'
----

And then execute:

[source,sh]
----
$ bundle install
----

Or install it yourself as:

[source,sh]
----
$ gem install lutaml-xsd
----

== Examples

The `examples/` directory contains practical demonstrations organized by complexity:

* **link:examples/01-simple/README.adoc[01-simple]** (â˜…â˜†â˜†â˜†â˜†) - Basic schemas with no dependencies, perfect for learning
  - Building LXR packages from YAML configuration
  - Type searching and resolution
  - Both Ruby API and CLI examples

* **link:examples/02-urban-function/README.adoc[02-urban-function]** (â˜…â˜…â˜…â˜…â˜†) - Complex i-UR schemas with extensive imports
  - Real-world Japanese urban planning standards
  - Schema location mapping patterns
  - 200+ types across multiple namespaces

* **link:examples/03-unitsml/README.adoc[03-unitsml]** (â˜…â˜…â˜†â˜†â˜†) - OASIS UnitsML scientific standard
  - Units of measure vocabulary
  - Self-contained scientific schemas
  - Domain-specific search examples

* **link:examples/04-metaschema/README.adoc[04-metaschema]** (â˜…â˜…â˜…â˜…â˜…) - NIST Metaschema (advanced)
  - Self-referential schema patterns
  - Meta-level type definitions
  - Schemas defining schemas

Each category includes:

* `config.yml` - Visible package configuration
* `ruby-api/example.rb` - Programmatic usage
* `cli/run.sh` - Command-line usage
* `README.adoc` - Category-specific documentation

See link:examples/README.md[examples/README.md] for complete guidance.

== Architecture

=== XSD object hierarchy

The following diagram illustrates the hierarchical structure of XSD objects
and their relationships:

[source]
----
                        Schema
                          â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚               â”‚               â”‚
       Elements      ComplexTypes    SimpleTypes
          â”‚               â”‚               â”‚
          â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”       â”‚
          â”‚       â”‚               â”‚       â”‚
      Attributes Sequences    Extensions  â”‚
          â”‚       â”‚           Restrictionsâ”‚
          â”‚   â”Œâ”€â”€â”€â”´â”€â”€â”€â”           â”‚       â”‚
          â”‚   â”‚       â”‚           â”‚       â”‚
      Groups Elements Choice      â”‚   Facets
                  â”‚               â”‚
                  â”‚               â”‚
              Attributes      Attributes
----

.XSD Model class relationships
[source]
----
   Schema
     â”œâ”€â”€ element: [Element]
     â”œâ”€â”€ complex_type: [ComplexType]
     â”œâ”€â”€ simple_type: [SimpleType]
     â”œâ”€â”€ attribute: [Attribute]
     â”œâ”€â”€ attribute_group: [AttributeGroup]
     â”œâ”€â”€ group: [Group]
     â”œâ”€â”€ notation: [Notation]
     â”œâ”€â”€ import: [Import]
     â””â”€â”€ include: [Include]

   Element
     â”œâ”€â”€ name: String
     â”œâ”€â”€ type: String
     â”œâ”€â”€ ref: String
     â”œâ”€â”€ min_occurs: String
     â”œâ”€â”€ max_occurs: String
     â”œâ”€â”€ complex_type: ComplexType
     â””â”€â”€ simple_type: SimpleType

   ComplexType
     â”œâ”€â”€ name: String
     â”œâ”€â”€ sequence: Sequence
     â”œâ”€â”€ choice: Choice
     â”œâ”€â”€ all: All
     â”œâ”€â”€ attribute: [Attribute]
     â”œâ”€â”€ attribute_group: [AttributeGroup]
     â”œâ”€â”€ simple_content: SimpleContent
     â””â”€â”€ complex_content: ComplexContent
----

=== Data transformation flow

The following diagram shows how XSD files are processed through the parsing
pipeline:

[source]
----
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   XSD File(s)     â•‘           â•‘  Schema Mappings      â•‘
â•‘                   â•‘           â•‘  (Local redirects)    â•‘
â•šâ•â•â•â•â•â•â•â•â•â”¬â•â•â•â•â•â•â•â•â•â•           â•šâ•â•â•â•â•â•â•â•â•â•â•â”¬â•â•â•â•â•â•â•â•â•â•â•â•
          â”‚                                 â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  XSD Parser    â”‚
              â”‚  (XML â†’ Model) â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚            â”‚            â”‚
          â–¼            â–¼            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Schema  â”‚  â”‚ Element â”‚  â”‚  Type   â”‚
    â”‚ Object  â”‚  â”‚ Objects â”‚  â”‚ Objects â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚            â”‚            â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  Manipulation  â”‚
              â”‚  & Traversal   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚            â”‚            â”‚
          â–¼            â–¼            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   XML   â”‚  â”‚  Liquid â”‚  â”‚  Code   â”‚
    â”‚ Output  â”‚  â”‚Template â”‚  â”‚  Gen    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

[[lxr-packages]]
== LutaML XML Repository (LXR) packages

=== General

A LutaML XML Repository (LXR) package is a self-contained, portable archive
format (`.lxr` file extension) designed for distributing and using XSD schema
collections. LXR packages solve the challenge of managing complex,
multi-schema XML applications by bundling schemas, their dependencies, and a
pre-built type index into a single, optimized file.

An LXR package is essentially a ZIP archive containing:

* XSD schema files (optional, based on configuration)
* Pre-serialized schema objects for instant loading
* A comprehensive type index for fast lookups
* Namespace and schema location mappings
* Package metadata (version, description, creation date)
* Statistics about types, elements, and namespaces

The `.lxr` extension stands for "LutaML XSD Repository", emphasizing its role
as a complete repository of schema information rather than just a collection
of files.

=== What problems do LXR packages solve?

LXR packages address several key challenges in working with XSD schemas:

==== Performance

Traditional workflow requires parsing XML schemas every time an application
starts, which can take seconds or even minutes for large schema sets like
CityGML or ISO/TC 211 standards.

.Traditional vs. LXR workflow
[source]
----
Traditional Workflow:
  XSD Files (scattered) â†’ Parse every time â†’ Slow startup â†’ External dependencies
  â”œâ”€ schema1.xsd (parse: 2s)
  â”œâ”€ schema2.xsd (parse: 3s)
  â””â”€ schema3.xsd (parse: 1s)
  Total: 6+ seconds on every startup

LXR Workflow:
  package.lxr â†’ Instant load â†’ Fast queries â†’ Self-contained
  Total: <100ms to load pre-serialized schemas
----

LXR packages eliminate this overhead by pre-serializing schemas and building
type indexes during package creation, not at runtime.

==== Distribution complexity

Distributing XSD schemas traditionally means sharing multiple files with
complex directory structures, external dependencies, and version
inconsistencies.

LXR packages provide:

* **Single-file distribution**: One `.lxr` file contains everything
* **Dependency bundling**: All referenced schemas included (optional)
* **Version tracking**: Metadata ensures schema version consistency
* **Offline capability**: No external fetching required

==== Type resolution challenges

Finding types across namespaces in multi-schema applications requires manual
tracking of imports, includes, and namespace URIs.

LXR packages offer:

* **Pre-built type index**: Instant qualified name lookups
* **Namespace-aware queries**: Resolve `gml:CodeType` without manual mapping
* **Cross-schema resolution**: Find types across all included schemas
* **Three name formats**: Support prefixed, Clark notation, and unprefixed
  names

=== What can you do with LXR packages?

LXR packages enable several practical use cases:

==== Distribute schema collections

Share complete schema sets with collaborators or users:

[source,bash]
----
# Create a CityGML package
lutaml-xsd package build citygml.yaml -o citygml-2.0.lxr

# Distribute the single .lxr file
# Recipients can immediately use it without setup
----

==== Build code generators

Use pre-indexed schemas for fast code generation:

[source,ruby]
----
# Load schema repository
repo = Lutaml::Xsd::SchemaRepository.from_package('schemas.lxr')

# Generate classes from types
repo.complex_types.each do |type|
  generate_class(type)
end
----

==== Create validation tools

Build XML validators with instant schema loading:

[source,ruby]
----
validator = XmlValidator.new(
  schema_package: 'validation.lxr'
)

result = validator.validate(xml_document)
----

==== Document schemas

Query types and relationships for documentation generation:

[source,bash]
----
# List all types
lutaml-xsd type list --from schemas.lxr --format yaml > types.yaml

# Find specific types
lutaml-xsd type find "gml:CodeType" --from schemas.lxr
----

==== Version control schemas

Track schema versions with embedded metadata:

[source,yaml]
----
# Package metadata
name: "CityGML Schemas"
version: "2.0.0"
created_at: "2024-10-24T18:00:00+08:00"
description: "Complete CityGML 2.0 schema set with dependencies"
----

==== Enable offline development

Work without network access to remote schemas:

[source,bash]
----
# Build package with all dependencies bundled
lutaml-xsd package build config.yaml \
  --xsd-mode include_all \
  --output offline_schemas.lxr

# Use offline
lutaml-xsd type find "uro:BuildingType" --from offline_schemas.lxr
----

=== LXR configuration options

LXR packages are highly configurable through three independent axes, allowing
you to optimize for your specific use case:

.LXR Package configuration matrix
[source]
----
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           LXR Package Configuration Matrix                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                           â•‘
â•‘  Axis 1: XSD Bundling Mode                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â•‘
â•‘  â”‚   include_all      â”‚    allow_external       â”‚        â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â•‘
â•‘  â”‚ â€¢ Bundle all XSDs  â”‚ â€¢ Keep URL references   â”‚        â•‘
â•‘  â”‚ â€¢ Rewrite paths    â”‚ â€¢ Smaller packages      â”‚        â•‘
â•‘  â”‚ â€¢ Self-contained   â”‚ â€¢ Requires network      â”‚        â•‘
â•‘  â”‚ â€¢ Larger file size â”‚ â€¢ Faster packaging      â”‚        â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â•‘
â•‘                                                           â•‘
â•‘  Axis 2: Resolution Mode                                 â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â•‘
â•‘  â”‚     resolved       â”‚         bare            â”‚        â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â•‘
â•‘  â”‚ â€¢ Pre-serialized   â”‚ â€¢ Parse on load         â”‚        â•‘
â•‘  â”‚ â€¢ Instant loading  â”‚ â€¢ Slower startup        â”‚        â•‘
â•‘  â”‚ â€¢ Larger packages  â”‚ â€¢ Best for editing      â”‚        â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â•‘
â•‘                                                           â•‘
â•‘  Axis 3: Serialization Format                            â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â•‘
â•‘  â”‚ marshal â”‚  json   â”‚  yaml   â”‚  parse   â”‚             â•‘
â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â•‘
â•‘  â”‚ Fastest â”‚Portable â”‚ Human   â”‚ No cache â”‚             â•‘
â•‘  â”‚ Binary  â”‚ Slower  â”‚readable â”‚ Smallest â”‚             â•‘
â•‘  â”‚ Ruby    â”‚ Cross   â”‚friendly â”‚ Always   â”‚             â•‘
â•‘  â”‚ only    â”‚platform â”‚       â”‚ parse    â”‚             â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

==== XSD bundling mode

Controls how XSD files are included in the package:

`include_all` (recommended)::
  * Bundles all XSD files into the package
  * Rewrites schema location paths to be package-relative
  * Creates fully self-contained packages
  * Larger file size but completely portable
  * No network access required

`allow_external`::
  * Keeps original schema location references
  * Package only contains metadata and indexes
  * Smaller file size
  * Requires network access or local schemas
  * Useful for development environments

==== Resolution mode

Controls whether schemas are pre-serialized:

`resolved` (recommended)::
  * Pre-serializes all parsed schema objects
  * Enables instant loading without XML parsing
  * Larger package size due to serialized data
  * Best for production use and queries
  * Type index immediately available

`bare`::
  * Only includes XSD files and minimal metadata
  * Schemas parsed on first load
  * Smaller package size
  * Slower startup
  * Best for schema development and editing

==== Serialization format

Controls how schemas are serialized (only relevant for `resolved` mode):

`marshal` (recommended for Ruby)::
  * Ruby's native serialization format
  * Fastest serialization and deserialization
  * Binary format, not human-readable
  * Ruby version dependent
  * Best for Ruby-only applications

`json`::
  * JSON serialization format
  * Cross-platform and cross-language compatible
  * Human-readable text format
  * Slower than marshal
  * Good for interoperability

`yaml`::
  * YAML serialization format
  * Most human-readable
  * Excellent for debugging
  * Slowest format
  * Best for development and inspection

`parse`::
  * No serialization, always parse XSD files
  * Smallest package size
  * Always fresh parsing
  * Slowest loading
  * Best when schemas change frequently

=== Creating LXR packages

LXR packages can be created in two ways: from a YAML configuration file or
interactively from the command line.

==== Via YAML configuration

The recommended approach for reproducible builds is using a YAML configuration
file.

Syntax:

[source,yaml]
----
files: <1>
  - path/to/schema.xsd

schema_location_mappings: <2>
  - from: "http://schemas.example.com/schema.xsd"
    to: "local/path/schema.xsd"

namespace_mappings: <3>
  - prefix: "ex"
    uri: "http://example.com/namespace"
----
<1> List of XSD files to include (required)
<2> Schema location mappings for imports/includes (optional)
<3> Namespace prefix mappings (optional)

Where,

`files`:: Array of XSD file paths to include in the package (required)
`schema_location_mappings`:: Array of schema location redirections (optional)
`namespace_mappings`:: Array of namespace prefix-to-URI mappings (optional)

.Creating a package from YAML configuration
[example]
[source,yaml]
----
# config/urban_function_repository.yaml
files:
  - spec/fixtures/i-ur/urbanFunction.xsd

schema_location_mappings:
  - from: "../../uro/3.2/urbanObject.xsd"
    to: "spec/fixtures/i-ur/urbanObject.xsd"

  - from: !ruby/regexp /(?:\.\.\/)+gml\/(.+\.xsd)$/
    to: "spec/fixtures/codesynthesis-gml-3.2.1/gml/\\1"

namespace_mappings:
  - prefix: "urf"
    uri: "https://www.geospatial.jp/iur/urf/3.2"

  - prefix: "gml"
    uri: "http://www.opengis.net/gml/3.2"
----

Build the package:

[source,bash]
----
lutaml-xsd package build config/urban_function_repository.yaml \
  --name "Urban Function Schema Repository" \
  --version "3.2" \
  --description "i-UR Urban Function schema with dependencies" \
  --xsd-mode include_all \
  --resolution-mode resolved \
  --serialization-format marshal \
  --output pkg/urban_function.lxr \
  --validate
----

Output:

----
âœ“ Configuration loaded
  Files: 1
  Schema Location Mappings: 2
  Namespace Mappings: 2

Parsing and resolving schemas...
âœ“ Schemas parsed and resolved

Creating package: pkg/urban_function.lxr
  XSD Mode: include_all
  Resolution Mode: resolved
  Serialization Format: marshal
âœ“ Package created: pkg/urban_function.lxr
  Size: 4683850 bytes

Validating package...
âœ“ Package is valid
----

==== Via command-line with minimal configuration

For quick package creation with a simple configuration, create a minimal YAML file:

NOTE: The `package build` command requires a YAML configuration file as input. Direct XSD file input is not supported.

.Building a package with minimal YAML configuration
[example]
[source,yaml]
----
# minimal_config.yaml
files:
  - path/to/schema.xsd
----

Then build the package:

[source,bash]
----
# Build with defaults (include_all, resolved, marshal)
lutaml-xsd package build minimal_config.yaml

# Build with custom options
lutaml-xsd package build config.yaml \
  --name "Urban Function Schema" \
  --version "3.2" \
  --description "i-UR Urban Function schema collection" \
  --xsd-mode include_all \
  --resolution-mode resolved \
  --serialization-format marshal \
  --output pkg/urban_function.lxr \
  --validate

# Build with JSON format for cross-platform use
lutaml-xsd package build config.yaml \
  --serialization-format json \
  --output schema.lxr

# Build bare package (parse on load)
lutaml-xsd package build config.yaml \
  --resolution-mode bare \
  --output schema_bare.lxr
----

==== CLI build options

The `lutaml-xsd package build` command supports these options:

`--output, -o PATH`::
  Output package path (default: `pkg/<name>.lxr`)

`--xsd-mode MODE`::
  XSD bundling mode: `include_all` or `allow_external` (default: `include_all`)

`--resolution-mode MODE`::
  Resolution mode: `resolved` or `bare` (default: `resolved`)

`--serialization-format FORMAT`::
  Serialization format: `marshal`, `json`, `yaml`, or `parse` (default:
  `marshal`)

`--name NAME`::
  Package name for metadata

`--version VERSION`::
  Package version for metadata

`--description DESC`::
  Package description for metadata

`--validate`::
  Validate package after building

`--verbose`::
  Enable verbose output

=== Using LXR packages

Once created, LXR packages can be used programmatically via the Ruby API or
interactively via the command-line interface.

==== Loading via Ruby API

.Loading and using an LXR package
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

# Load package
repository = Lutaml::Xsd::SchemaRepository.from_package(
  'pkg/urban_function.lxr'
)

# Package loads instantly (pre-serialized schemas)
puts "Loaded in milliseconds!"

# Query types
result = repository.find_type('gml:CodeType')
if result.resolved?
  puts "Found: #{result.qname}"
  puts "Namespace: #{result.namespace}"
end

# Get statistics
stats = repository.statistics
puts "Total types: #{stats[:total_types]}"
puts "Total namespaces: #{stats[:total_namespaces]}"

# List types by category
stats[:types_by_category].each do |category, count|
  puts "#{category}: #{count}"
end
----
====

==== Using via command-line interface

The CLI provides convenient commands for working with packages:

.Package information and validation
[example]
[source,bash]
----
# Display package metadata
lutaml-xsd package info pkg/urban_function.lxr

# Validate package structure
lutaml-xsd package validate pkg/urban_function.lxr

# Validate with strict mode (fail on warnings)
lutaml-xsd package validate pkg/urban_function.lxr --strict

# Get validation results in JSON
lutaml-xsd package validate pkg/urban_function.lxr --format json
----

Output from `package info`:

----
Package: urban_function.lxr
Size: 4683850 bytes

Metadata:
--------------------------------------------------------------------------------
name: Urban Function Schema Repository
version: 3.2
description: i-UR Urban Function schema with dependencies
created_at: 2024-10-24T17:11:33+08:00
lutaml_xsd_version: 1.0.4
created_by: lutaml-xsd CLI
xsd_mode: include_all
resolution_mode: resolved
serialization_format: marshal
files: 1
namespace_mappings: 4
schema_location_mappings: 2
----

.Type queries
[example]
[source,bash]
----
# Find a specific type
lutaml-xsd type find "gml:CodeType" --from pkg/urban_function.lxr

# Find with JSON output
lutaml-xsd type find "gml:CodeType" \
  --from pkg/urban_function.lxr \
  --format json

# List all types
lutaml-xsd type list --from pkg/urban_function.lxr

# List types in specific namespace
lutaml-xsd type list \
  --from pkg/urban_function.lxr \
  --namespace "http://www.opengis.net/gml/3.2"

# List types by category
lutaml-xsd type list \
  --from pkg/urban_function.lxr \
  --category complex_type
----

Output from `type find`:

----
Type Resolution: gml:CodeType

âœ“ Type found

Qualified Name: gml:CodeType
Namespace: http://www.opengis.net/gml/3.2
Local Name: CodeType
Schema File: basicTypes.xsd
Type Class: Lutaml::Xsd::ComplexType

Documentation:
  gml:CodeType is a generalized type to be used for a term, keyword or name.
  It adds a XML attribute codeSpace to a term, where the value of the
  codeSpace attribute (if present) shall indicate a dictionary, thesaurus,
  classification scheme, authority, or pattern for the term.

Simple Content:
  Extension:
    Base: string
    Attributes:
      - codeSpace: anyURI (optional)
----

.Repository statistics
[example]
[source,bash]
----
# Display repository statistics
lutaml-xsd stats show pkg/urban_function.lxr

# Get statistics in YAML format
lutaml-xsd stats show pkg/urban_function.lxr --format yaml
----

Output:

----
Repository Statistics:
  Total schemas parsed: 0
  Total types indexed: 2764
  Types by category:
    attribute_group: 68
    complex_type: 1356
    element: 1221
    group: 27
    simple_type: 92
  Total namespaces: 34
----

=== LXR package internals

Understanding the internal structure of LXR packages helps with debugging and
optimization.

.LXR package internal structure
[source]
----
my_schemas.lxr (ZIP archive)
â”œâ”€â”€ metadata.yaml              # Package metadata
â”‚   â”œâ”€â”€ name: "Schema Collection"
â”‚   â”œâ”€â”€ version: "1.0"
â”‚   â”œâ”€â”€ created_at: "2024-10-24T18:00:00+08:00"
â”‚   â”œâ”€â”€ xsd_mode: "include_all"
â”‚   â”œâ”€â”€ resolution_mode: "resolved"
â”‚   â””â”€â”€ serialization_format: "marshal"
â”‚
â”œâ”€â”€ xsd_files/                 # Bundled XSD files (if include_all)
â”‚   â”œâ”€â”€ schema1.xsd
â”‚   â”œâ”€â”€ schema2.xsd
â”‚   â””â”€â”€ dependencies/
â”‚       â””â”€â”€ common.xsd
â”‚
â”œâ”€â”€ schemas/                   # Serialized schemas (if resolved)
â”‚   â”œâ”€â”€ schema1.marshal        # (or .json, .yaml based on format)
â”‚   â””â”€â”€ schema2.marshal
â”‚
â”œâ”€â”€ type_index.marshal         # Pre-built type index
â”‚   â”œâ”€â”€ namespace -> types mapping
â”‚   â”œâ”€â”€ qualified name -> type mapping
â”‚   â””â”€â”€ category -> types mapping
â”‚
â”œâ”€â”€ namespace_mappings.yaml    # Namespace prefix mappings
â”‚   â””â”€â”€ - prefix: "gml"
â”‚       uri: "http://www.opengis.net/gml/3.2"
â”‚
â””â”€â”€ schema_location_mappings.yaml  # Schema location mappings
    â””â”€â”€ - from: "http://example.com/schema.xsd"
        to: "local/schema.xsd"
----

==== Metadata structure

The `metadata.yaml` file contains:

[source,yaml]
----
name: "Schema Collection"
version: "1.0"
description: "Complete schema set with dependencies"
created_at: "2024-10-24T18:00:00+08:00"
created_by: "lutaml-xsd CLI"
lutaml_xsd_version: "1.0.4"

# Configuration
xsd_mode: "include_all"
resolution_mode: "resolved"
serialization_format: "marshal"

# Content summary
files: 3
namespace_mappings: 4
schema_location_mappings: 2

# Statistics
statistics:
  total_schemas: 3
  total_types: 150
  types_by_category:
    complex_type: 80
    simple_type: 30
    element: 35
    attribute_group: 5
  total_namespaces: 3
  namespace_prefixes: 4
  resolved: true
  validated: true
----

==== Type index structure

The type index enables fast lookups:

[source,ruby]
----
# Conceptual structure (serialized format varies)
{
  by_namespace: {
    "http://www.opengis.net/gml/3.2" => {
      "CodeType" => <TypeDefinition>,
      "MeasureType" => <TypeDefinition>
    }
  },

  by_qualified_name: {
    "gml:CodeType" => <TypeDefinition>,
    "{http://www.opengis.net/gml/3.2}CodeType" => <TypeDefinition>
  },

  by_category: {
    complex_type: [<TypeDefinition>, ...],
    simple_type: [<TypeDefinition>, ...],
    element: [<TypeDefinition>, ...]
  }
}
----

=== Best practices for LXR packages

==== Choosing XSD bundling mode

Use `include_all` when:

* Distributing schemas to users who may not have internet access
* Creating portable, self-contained packages
* Ensuring consistent schema versions
* Working with schemas from multiple sources

Use `allow_external` when:

* Working in development environments
* Schemas change frequently
* Package size is critical
* Network access to schemas is guaranteed

==== Choosing resolution mode

Use `resolved` when:

* Building production packages
* Optimizing for query performance
* Creating packages for repeated use
* Package size is not a constraint

Use `bare` when:

* Developing or editing schemas
* Package size is critical
* Schemas change frequently between builds
* One-time use packages

==== Choosing serialization format

Use `marshal` when:

* Building Ruby-only applications
* Performance is critical
* Package size and speed are both important
* Ruby version is consistent

Use `json` when:

* Cross-platform compatibility needed
* Integrating with non-Ruby tools
* Some human readability desired
* Moderate performance acceptable

Use `yaml` when:

* Debugging packages
* Maximum human readability needed
* Performance is not critical
* Inspecting package contents manually

Use `parse` when:

* Schemas change very frequently
* Smallest possible package size needed
* Always want fresh parsing
* No serialization overhead acceptable

==== Package versioning

Include version information in metadata:

[source,bash]
----
lutaml-xsd package build config.yaml \
  --name "CityGML Schemas" \
  --version "2.0.0" \
  --description "CityGML 2.0 complete schema set" \
  --output citygml-2.0.0.lxr
----

Use semantic versioning:

* MAJOR version for incompatible schema changes
* MINOR version for backward-compatible additions
* PATCH version for bug fixes and documentation

==== Distribution recommendations

* Include a README with package contents and version
* Document required Ruby version for marshal packages
* Provide checksums (SHA256) for package verification
* Host packages in version-controlled repositories
* Create separate packages for major schema versions

==== Package optimization

For smallest packages:

[source,bash]
----
lutaml-xsd package build config.yaml \
  --xsd-mode allow_external \
  --resolution-mode bare \
  --serialization-format parse
----

For fastest loading:

[source,bash]
----
lutaml-xsd package build config.yaml \
  --xsd-mode include_all \
  --resolution-mode resolved \
  --serialization-format marshal
----

For maximum portability:

[source,bash]
----
lutaml-xsd package build config.yaml \
  --xsd-mode include_all \
  --resolution-mode resolved \
  --serialization-format json
----

[[parsing-xsd]]
== Parsing XSD files

=== General

To parse an XSD file, use the `Lutaml::Xsd.parse` method. This method takes
the content of an XSD file as a string and optional parameters such as the
location of the XSD file for resolving relative paths.

Syntax:

[source,ruby]
----
Lutaml::Xsd.parse(xsd_content, location: {location}, schema_mappings: {mappings}) <1>
----
<1> Parse XSD content with optional location and mappings

Where,

`xsd_content`:: The XSD file content as a string (required)
`location`:: The base path or URL for resolving relative schema locations
  (optional)
`schema_mappings`:: An array of hash mappings for redirecting schema locations
  (optional)

.Parsing an XSD file with location context
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

xsd_content = File.read('path/to/your/schema.xsd')
parsed_schema = Lutaml::Xsd.parse(
  xsd_content,
  location: 'path/to/your/'
)

# Access schema properties
puts "Target namespace: #{parsed_schema.target_namespace}"
puts "Element count: #{parsed_schema.element.size}"
puts "Complex type count: #{parsed_schema.complex_type.size}"
puts "Simple type count: #{parsed_schema.simple_type.size}"
puts "Attribute count: #{parsed_schema.attribute.size}"
puts "Group count: #{parsed_schema.group.size}"
puts "Attribute group count: #{parsed_schema.attribute_group.size}"
puts "Import count: #{parsed_schema.import.size}"
puts "Include count: #{parsed_schema.include.size}"
----

This example parses an XSD file and displays basic schema information.
====

=== Working with parsed data

Once parsed, the data is represented as instances of various classes such as
`Lutaml::Xsd::Schema`, `Lutaml::Xsd::Element`, and others. These objects
reflect the structure of the XSD and can be manipulated or inspected in Ruby.

.Accessing schema elements
[example]
====
[source,ruby]
----
schema = <<~SCHEMA
  <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <xsd:element name="root">
      <xsd:complexType>
        <xsd:sequence>
          <xsd:element name="child" type="xsd:string"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:element>
    <xsd:element name="root1">
      <xsd:complexType>
        <xsd:attribute name="id" type="xsd:string"/>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
SCHEMA

parsed_schema = Lutaml::Xsd.parse(
  schema,
  location: 'http://example.com/'
)

# Iterate through elements
parsed_schema.element.each do |element|
  puts "Element name: #{element.name}"

  if element.complex_type
    puts "  Has complex type"

    # Access sequences
    if element.complex_type.sequence
      element.complex_type.sequence.element.each do |child|
        puts "    Child element: #{child.name}"
      end
    end

    # Access attributes
    element.complex_type.attribute.each do |attr|
      puts "    Attribute: #{attr.name}"
    end
  end
end
----

Output:

----
Element name: root
  Has complex type
    Child element: child
Element name: root1
  Has complex type
    Attribute: id
----
====

[[schema-representation]]
== Schema representation

The `Lutaml::Xsd::Schema` class represents an XSD schema. It includes
attributes for various schema properties like target namespace, element form
default, and collections of schema components.

.Schema object properties
[example]
====
[source,ruby]
----
# Access schema-level properties
puts "Target namespace: #{parsed_schema.target_namespace}"
puts "Element form default: #{parsed_schema.element_form_default}"
puts "Attribute form default: #{parsed_schema.attribute_form_default}"

# Access schema components
puts "Elements: #{parsed_schema.element.size}"
puts "Complex types: #{parsed_schema.complex_type.size}"
puts "Simple types: #{parsed_schema.simple_type.size}"
puts "Attributes: #{parsed_schema.attribute.size}"
puts "Groups: #{parsed_schema.group.size}"
puts "Attribute groups: #{parsed_schema.attribute_group.size}"
puts "Imports: #{parsed_schema.import.size}"
puts "Includes: #{parsed_schema.include.size}"
----
====

[[include-import]]
== Include and import handling

=== General

The `location` parameter provided to `Lutaml::Xsd.parse` is used for
resolving relative paths specified in `<xs:include>` and `<xs:import>`
elements' `schemaLocation` attributes.

Make sure to provide the directory path or URL in the `location` parameter,
as it will be used as the base path for resolving relative paths.

=== Using URL locations

.Parsing with a URL base location
[example]
====
[source,ruby]
----
Lutaml::Xsd.parse(
  xsd_content,
  location: 'http://example.com/schemas/'
)
----

The schema can include references like:

[source,xml]
----
<xs:include schemaLocation="common/types.xsd"/>
<xs:import schemaLocation="external/definitions.xsd"/>
----

These will be resolved as:

* `http://example.com/schemas/common/types.xsd`
* `http://example.com/schemas/external/definitions.xsd`
====

=== Using local file paths

.Parsing with a local base path
[example]
====
[source,ruby]
----
Lutaml::Xsd.parse(
  xsd_content,
  location: '/path/to/schemas/'
)
----

The schema can include references like:

[source,xml]
----
<xs:include schemaLocation="common/types.xsd"/>
<xs:import schemaLocation="../external/definitions.xsd"/>
----

These will be resolved as:

* `/path/to/schemas/common/types.xsd`
* `/path/to/external/definitions.xsd`
====

All schemas specified in the `<xs:include>` and `<xs:import>` elements will
be fetched from their `schemaLocation`, parsed, and added to their parent
`Lutaml::Xsd::Schema` object.

[[schema-mappings]]
== Schema location mappings

=== General

When parsing XSD files that import or include schemas from remote URLs, you
may want to override those locations to use local copies instead. This is
especially useful when:

* Remote schemas are unavailable or inaccessible
* You want to work offline
* You have local copies of standard schemas (e.g., CityGML, GML, ISO/TC 211)
* You need to ensure consistent schema versions

The `schema_mappings` parameter allows you to provide an array of mappings
that redirect original schema locations to local file paths or alternative
URLs.

NOTE: For comprehensive documentation on schema mappings, including advanced
patterns, CityGML/i-UR examples, debugging techniques, and best practices,
see link:docs/schema_mapping.adoc[Advanced Schema Location Mappings].

=== Basic usage

Schema mappings use a simple array of hash objects with `from` and `to` keys.

.Basic schema mapping example
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

xsd_content = File.read('path/to/your/schema.xsd')

# Define schema location mappings
schema_mappings = [
  # Exact string match
  {
    from: 'http://schemas.opengis.net/gml/3.1.1/base/gml.xsd',
    to: '/local/path/to/gml.xsd'
  },

  # Regex pattern with capture group
  {
    from: %r{http://schemas\.opengis\.net/citygml/(.+)},
    to: '/local/citygml/\1'
  }
]

parsed_schema = Lutaml::Xsd.parse(
  xsd_content,
  location: 'path/to/your/',
  schema_mappings: schema_mappings
)
----

The first mapping uses exact string matching, while the second uses a regular
expression with a capture group (`\1`) to map an entire directory structure.

[source,ruby]
----
require 'lutaml/xsd'

xsd_content = File.read('path/to/your/schema.xsd')

# Define schema location mappings (array of hashes with from/to keys)
schema_mappings = [
  # Exact string match
  {
    from: 'http://schemas.opengis.net/gml/3.1.1/base/gml.xsd',
    to: '/local/path/to/gml.xsd'
  },

  # Relative path mapping
  {
    from: '../../external/schema.xsd',
    to: '/absolute/path/to/schema.xsd'
  }
]

parsed_schema = Lutaml::Xsd.parse(
  xsd_content,
  location: 'path/to/your/',
  schema_mappings: schema_mappings
)
----

This example redirects two schema locations to local files.
====

=== Pattern-based mappings with regular expressions

For more flexible mappings, you can use regular expressions in the `from`
field. This is particularly useful when you need to map multiple schemas
under a common base URL.

.Using regex patterns for schema mappings
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

# Path to your i-UR schema that imports CityGML schemas
xsd_file = 'spec/fixtures/i-ur/urbanFunction.xsd'
xsd_content = File.read(xsd_file)

# Define pattern-based mappings using regex in the 'from' field
schema_mappings = [
  # Map all CityGML schemas to local directory using regex pattern
  {
    from: %r{http://schemas\.opengis\.net/citygml/(.+)},
    to: File.expand_path('../fixtures/citygml/\1', __dir__)
  },

  {
    from: %r{http://schemas\.opengis\.net/citygml/appearance/2\.0/(.+)},
    to: File.expand_path('spec/fixtures/citygml/appearance/2.0/\1', __dir__)
  },

  {
    from: %r{http://schemas\.opengis\.net/citygml/building/2\.0/(.+)},
    to: File.expand_path('spec/fixtures/citygml/building/2.0/\1', __dir__)
  },

  # Map i-UR schema imports
  {
    from: '../../uro/3.2/urbanObject.xsd',
    to: File.expand_path('spec/fixtures/i-ur/urbanObject.xsd', __dir__)
  }
]

parsed_schema = Lutaml::Xsd.parse(
  xsd_content,
  location: File.dirname(
    File.expand_path('spec/fixtures/i-ur/urbanFunction.xsd')
  ),
  schema_mappings: schema_mappings
)
----

In the regex pattern example above:

* The `from` field contains the pattern
  `%r{http://schemas\.opengis\.net/citygml/(.+)}` which matches any URL
  starting with `http://schemas.opengis.net/citygml/`
* The capture group `(.+)` captures the rest of the path
* The `to` field uses `\1` to insert the captured path portion in the
  replacement
* This allows mapping `http://schemas.opengis.net/citygml/2.0/cityGMLBase.xsd`
  to `/local/path/citygml/2.0/cityGMLBase.xsd`
====

=== Working with CityGML and i-UR schemas

When working with CityGML and i-UR (Urban and Rural) schemas, which commonly
reference remote OGC schemas:

.Mapping CityGML schemas to local copies
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

# Path to your i-UR schema that imports CityGML schemas
xsd_content = File.read('spec/fixtures/i-ur/urbanFunction.xsd')

# Map remote CityGML schemas to local copies (array of mappings)
schema_mappings = [
  # Map all CityGML schemas from OGC to local directory
  {
    from: %r{http://schemas\.opengis\.net/citygml/2\.0/(.+)},
    to: File.expand_path('spec/fixtures/citygml/2.0/\1', __dir__)
  },

  {
    from: %r{http://schemas\.opengis\.net/citygml/appearance/2\.0/(.+)},
    to: File.expand_path('spec/fixtures/citygml/appearance/2.0/\1', __dir__)
  },

  {
    from: %r{http://schemas\.opengis\.net/citygml/building/2\.0/(.+)},
    to: File.expand_path('spec/fixtures/citygml/building/2.0/\1', __dir__)
  },

  # Map i-UR schema imports
  {
    from: '../../uro/3.2/urbanObject.xsd',
    to: File.expand_path('spec/fixtures/i-ur/urbanObject.xsd', __dir__)
  }
]

parsed_schema = Lutaml::Xsd.parse(
  xsd_content,
  location: File.dirname(File.expand_path('spec/fixtures/i-ur/urbanFunction.xsd')),
  schema_mappings: schema_mappings
)
----
====

=== Mapping resolution order

The schema mapping resolution follows this order:

. *Check schema mappings* â€” Iterate through the mappings array in order
. For each mapping, check if the `from` field matches:
  * If `from` is a String and matches exactly, use the `to` value
  * If `from` is a Regexp and matches the location, substitute using the `to`
    value
. *If no mapping matches, try URL fetching* â€” The system will attempt to
  fetch the schema from its original URL
. *Fall back to relative path resolution* â€” Resolve as a relative path from
  the location parameter

When multiple mappings could match, the first matching mapping in the array
is used. This allows you to control precedence by ordering your mappings
appropriately.

IMPORTANT: Overly broad regex patterns can prevent the built-in URL fetching
from working. Only map schemas that you have locally.

=== Best practices for schema mappings

==== Keep mappings minimal

Only map schemas that you actually have available locally. Don't create
mappings for schemas that should be fetched from URLs.

.Comparing broad vs. specific mappings
[example]
====
[source,ruby]
----
# BAD - too broad, blocks URL fetching for ALL .xsd files
schema_mappings = [
  {
    from: %r{^([^/]+\.xsd)$},  # Catches everything!
    to: '/local/path/\1'
  }
]

# GOOD - specific to files you have locally
schema_mappings = [
  {
    from: %r{^(gml|gmlBase|feature)\.xsd$},  # Only specific files
    to: '/local/path/gml/\1.xsd'
  }
]
----
====

==== Order matters - specific before general

Place more specific patterns before more general ones to ensure correct
matching.

.Ordering mappings from specific to general
[example]
====
[source,ruby]
----
schema_mappings = [
  # Specific relative path first
  {
    from: '../../uro/3.2/urbanObject.xsd',
    to: '/local/path/urbanObject.xsd'
  },

  # General pattern for GML schemas
  {
    from: %r{(?:\.\./)+gml/(.+\.xsd)$},
    to: '/local/path/gml/\1'
  }
]
----
====

==== Use capture groups for flexible mappings

Regex capture groups allow you to map entire directory structures
efficiently.

.Using capture groups to map directory structures
[example]
====
[source,ruby]
----
# Maps: ../../gml/3.2.1/gml.xsd
#   to: /local/codesynthesis/gml/3.2.1/gml.xsd
# And:  ../../../../gml/3.2.1/feature.xsd
#   to: /local/codesynthesis/gml/3.2.1/feature.xsd
{
  from: %r{(?:\.\./)+gml/(.+\.xsd)$},
  to: '/local/codesynthesis/gml/\1'
}
----
====

==== Let URL fetching work

The system has built-in support for fetching schemas from HTTP/HTTPS URLs.
Don't block this with overly broad mappings.

.Allowing URL fetching for unmapped schemas
[example]
====
[source,ruby]
----
# This lets sweCommon.xsd be fetched from its URL automatically
schema_mappings = [
  # Only map what you have locally
  {
    from: %r{^(gml|gmlBase|feature)\.xsd$},
    to: '/local/path/gml/\1.xsd'
  }

  # sweCommon.xsd will be fetched from URL - no mapping needed!
]
----
====

=== Complete example with best practices

.Comprehensive schema mapping example
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

xsd_content = File.read('spec/fixtures/i-ur/urbanFunction.xsd')

# Targeted mappings following best practices
schema_mappings = [
  # 1. Specific relative path (exact match)
  {
    from: '../../uro/3.2/urbanObject.xsd',
    to: File.expand_path('spec/fixtures/i-ur/urbanObject.xsd')
  },

  # 2-4. Relative path patterns (handles any number of ../)
  {
    from: %r{(?:\.\./)+xlink/(.+\.xsd)$},
    to: File.expand_path('spec/fixtures/codesynthesis-gml-3.2.1/xlink/\1')
  },
  {
    from: %r{(?:\.\./)+gml/(.+\.xsd)$},
    to: File.expand_path('spec/fixtures/codesynthesis-gml-3.2.1/gml/\1')
  },
  {
    from: %r{(?:\.\./)+iso/(.+\.xsd)$},
    to: File.expand_path('spec/fixtures/codesynthesis-gml-3.2.1/iso/\1')
  },

  # 5-10. Simple relative paths for ISO metadata schemas
  {
    from: %r{^\.\./gmd/(.+\.xsd)$},
    to: File.expand_path(
      'spec/fixtures/codesynthesis-gml-3.2.1/iso/19139/20070417/gmd/\1'
    )
  },
  {
    from: %r{^\.\./gss/(.+\.xsd)$},
    to: File.expand_path(
      'spec/fixtures/codesynthesis-gml-3.2.1/iso/19139/20070417/gss/\1'
    )
  },
  {
    from: %r{^\.\./gts/(.+\.xsd)$},
    to: File.expand_path(
      'spec/fixtures/codesynthesis-gml-3.2.1/iso/19139/20070417/gts/\1'
    )
  },
  {
    from: %r{^\.\./gsr/(.+\.xsd)$},
    to: File.expand_path(
      'spec/fixtures/codesynthesis-gml-3.2.1/iso/19139/20070417/gsr/\1'
    )
  },
  {
    from: %r{^\.\./gco/(.+\.xsd)$},
    to: File.expand_path(
      'spec/fixtures/codesynthesis-gml-3.2.1/iso/19139/20070417/gco/\1'
    )
  },
  {
    from: %r{^\.\./gmx/(.+\.xsd)$},
    to: File.expand_path(
      'spec/fixtures/codesynthesis-gml-3.2.1/iso/19139/20070417/gmx/\1'
    )
  },

  # Bare filename patterns (specific files only)
  {
    from: %r{^(basicTypes|coordinateOperations|gml|feature|geometry)\.xsd$},
    to: File.expand_path('spec/fixtures/codesynthesis-gml-3.2.1/gml/3.2.1/\1.xsd')
  },

  # URL mappings
  {
    from: %r{https://schemas\.isotc211\.org/(.+)},
    to: File.expand_path('spec/fixtures/codesynthesis-gml-3.2.1/iso/\1')
  },
  {
    from: %r{(?:\.\./)+(\d{5}/.+\.xsd)$},
    to: File.expand_path('spec/fixtures/isotc211/\1')
  }
]

parsed_schema = Lutaml::Xsd.parse(
  xsd_content,
  location: File.dirname('spec/fixtures/i-ur/urbanFunction.xsd'),
  schema_mappings: schema_mappings
)

# Access parsed data
puts "Target namespace: #{parsed_schema.target_namespace}"
puts "Elements: #{parsed_schema.element.size}"
puts "Complex types: #{parsed_schema.complex_type.size}"
puts "Imports: #{parsed_schema.import.size}"
----

This example demonstrates:

* Minimal, targeted mappings (only for local files)
* Proper ordering (specific before general)
* Effective use of regex patterns and capture groups
* Leaving room for automatic URL fetching
====

[[schema-repository]]
== SchemaRepository

=== General

The `SchemaRepository` provides namespace-aware type resolution across
multiple XSD schemas. It builds a comprehensive index of all types, elements,
and other schema components, enabling efficient lookups by qualified names
in multiple formats.

This feature is particularly valuable when working with complex schema sets
like CityGML, GML, ISO/TC 211 standards, or any multi-schema XML application
where types need to be resolved across namespace boundaries.

Key capabilities:

* Parse and index multiple schemas with their imports and includes
* Resolve types using prefixed names (`gml:CodeType`), Clark notation
  (`{http://...}CodeType`), or unprefixed names
* Validate schema consistency and detect circular dependencies
* Query schema statistics and component counts
* Export and import schema collections as ZIP packages
* Integrate seamlessly with schema location mappings

=== Creating a schema repository

.Basic repository initialization
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

# Create a new repository
repo = Lutaml::Xsd::SchemaRepository.new

# Optionally specify a base directory for relative paths
repo = Lutaml::Xsd::SchemaRepository.new(
  base_dir: '/path/to/schemas'
)
----
====

=== Configuring namespaces

Before parsing schemas, configure namespace prefix-to-URI mappings to enable
prefixed name resolution.

Syntax:

[source,ruby]
----
repo.add_namespace_mapping(prefix: {prefix}, uri: {uri}) <1>
----
<1> Register a namespace prefix and its corresponding URI

Where,

`prefix`:: The namespace prefix (e.g., `"gml"`, `"xlink"`) (required)
`uri`:: The full namespace URI (e.g., `"http://www.opengis.net/gml/3.2"`)
  (required)

.Configuring namespace mappings
[example]
====
[source,ruby]
----
repo = Lutaml::Xsd::SchemaRepository.new

# Add namespace mappings for common schemas
repo.add_namespace_mapping(
  prefix: 'gml',
  uri: 'http://www.opengis.net/gml/3.2'
)

repo.add_namespace_mapping(
  prefix: 'xlink',
  uri: 'http://www.w3.org/1999/xlink'
)

repo.add_namespace_mapping(
  prefix: 'gco',
  uri: 'http://www.isotc211.org/2005/gco'
)
----
====

Namespace mappings enable resolving qualified names like `gml:CodeType` to
their full namespace URIs.

=== Parsing and resolving schemas

Use `parse_schema` to load a schema into the repository. The method
automatically processes all imports and includes, building a complete
index of types and components.

Syntax:

[source,ruby]
----
repo.parse_schema(
  content: {content},
  location: {location},
  schema_mappings: {mappings}
) <1>
----
<1> Parse a schema with optional location and mappings

Where,

`content`:: The XSD schema content as a string (required)
`location`:: Base path or URL for resolving relative schema locations
  (optional)
`schema_mappings`:: Array of schema location mappings for local/remote
  redirection (optional)

.Parsing a schema with location mappings
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

repo = Lutaml::Xsd::SchemaRepository.new

# Configure namespaces
repo.add_namespace_mapping(prefix: 'gml', uri: 'http://www.opengis.net/gml/3.2')
repo.add_namespace_mapping(prefix: 'uro', uri: 'https://www.geospatial.jp/iur/uro/3.2')
repo.add_namespace_mapping(prefix: 'urf', uri: 'https://www.geospatial.jp/iur/urf/3.2')

# Read schema content
xsd_content = File.read('spec/fixtures/i-ur/urbanFunction.xsd')

# Define schema mappings for imports
schema_mappings = [
  {
    from: '../../uro/3.2/urbanObject.xsd',
    to: File.expand_path('spec/fixtures/i-ur/urbanObject.xsd')
  },
  {
    from: %r{(?:\.\./)+gml/(.+\.xsd)$},
    to: File.expand_path('spec/fixtures/gml/\1')
  }
]

# Parse the schema - this will also parse all imports/includes
result = repo.parse_schema(
  content: xsd_content,
  location: File.dirname('spec/fixtures/i-ur/urbanFunction.xsd'),
  schema_mappings: schema_mappings
)

puts "Parsed: #{result.location}"
puts "Namespace: #{result.target_namespace}"
----
====

The repository automatically follows all `xs:import` and `xs:include`
directives, parsing referenced schemas and adding them to the index.

=== Resolving type references

After parsing schemas, use `resolve_type` to look up types by qualified name.
The method supports three name formats:

* Prefixed: `gml:CodeType`
* Clark notation: `{http://www.opengis.net/gml/3.2}CodeType`
* Unprefixed: `CodeType` (searches all namespaces)

Syntax:

[source,ruby]
----
result = repo.resolve_type(qualified_name: {name}) <1>
----
<1> Resolve a type by its qualified name

Where,

`qualified_name`:: The type name in any supported format (required)

Returns a `TypeResolutionResult` with:

`found?`:: Boolean indicating if the type was found
`type`:: The resolved type object (if found)
`namespace`:: The namespace URI of the type
`local_name`:: The local name portion of the type

.Resolving types by qualified name
[example]
====
[source,ruby]
----
# Resolve using prefixed name
result = repo.resolve_type(qualified_name: 'gml:CodeType')

if result.found?
  puts "Found: #{result.type.name}"
  puts "Namespace: #{result.namespace}"
  puts "Local name: #{result.local_name}"
end

# Resolve using Clark notation
result = repo.resolve_type(
  qualified_name: '{http://www.opengis.net/gml/3.2}CodeType'
)

# Resolve using unprefixed name (searches all namespaces)
result = repo.resolve_type(qualified_name: 'CodeType')

# Check resolution status
unless result.found?
  puts "Type not found: #{result.local_name}"
end
----
====

=== Finding types and components

The `find_type` method searches for types across all parsed schemas.

Syntax:

[source,ruby]
----
type = repo.find_type(name: {name}, namespace: {namespace}) <1>
----
<1> Find a type by name and optional namespace

Where,

`name`:: The local name of the type (required)
`namespace`:: The namespace URI to search in (optional - searches all if
  omitted)

.Finding types across namespaces
[example]
====
[source,ruby]
----
# Find in specific namespace
type = repo.find_type(
  name: 'CodeType',
  namespace: 'http://www.opengis.net/gml/3.2'
)

if type
  puts "Found: #{type.name}"
end

# Find across all namespaces (may return first match)
type = repo.find_type(name: 'CodeType')
----
====

=== Validation

The repository can validate schema consistency, including detection of:

* Missing type definitions
* Circular schema dependencies
* Invalid namespace references
* Unresolved imports

Syntax:

[source,ruby]
----
validation = repo.validate <1>
----
<1> Validate all schemas in the repository

Returns a hash with:

`valid?`:: Boolean indicating overall validity
`errors`:: Array of validation error messages
`warnings`:: Array of validation warnings

.Validating schema consistency
[example]
====
[source,ruby]
----
# Validate the repository
validation = repo.validate

if validation[:valid?]
  puts "All schemas are valid!"
else
  puts "Validation errors:"
  validation[:errors].each do |error|
    puts "  - #{error}"
  end
end

if validation[:warnings].any?
  puts "Warnings:"
  validation[:warnings].each do |warning|
    puts "  - #{warning}"
  end
end
----
====

=== Statistics and queries

The repository provides comprehensive statistics about parsed schemas.

.Querying repository statistics
[example]
====
[source,ruby]
----
# Get overall statistics
stats = repo.statistics

puts "Total schemas: #{stats[:total_schemas]}"
puts "Total namespaces: #{stats[:total_namespaces]}"
puts "Total types: #{stats[:total_types]}"
puts "Total elements: #{stats[:total_elements]}"

# List all namespaces
repo.namespaces.each do |uri|
  puts "Namespace: #{uri}"
end

# Get schema count
puts "Schemas loaded: #{repo.schema_count}"

# Check if specific namespace exists
if repo.namespace?('http://www.opengis.net/gml/3.2')
  puts "GML namespace is loaded"
end

# Get types in a specific namespace
types = repo.types_in_namespace('http://www.opengis.net/gml/3.2')
puts "GML has #{types.size} types"
----
====

=== Packaging schemas

The repository can export schema collections as ZIP packages with metadata,
and import them later for distribution or caching.

==== Exporting to ZIP

Syntax:

[source,ruby]
----
repo.export_to_zip(
  output_path: {path},
  metadata: {metadata}
) <1>
----
<1> Export repository to a ZIP package

Where,

`output_path`:: Path where the ZIP file will be created (required)
`metadata`:: Hash of metadata to include (e.g., `name`, `version`,
  `description`) (optional)

.Exporting a schema repository
[example]
====
[source,ruby]
----
# Export repository to ZIP with metadata
repo.export_to_zip(
  output_path: 'citygml_schemas.zip',
  metadata: {
    name: 'CityGML Schemas',
    version: '2.0',
    description: 'Complete CityGML 2.0 schema set with dependencies',
    created_at: Time.now.iso8601
  }
)

puts "Exported to citygml_schemas.zip"
----
====

The ZIP package contains:

* All parsed XSD schema files
* `metadata.yaml` with repository information
* Namespace mappings
* Schema location mappings

==== Importing from ZIP

Syntax:

[source,ruby]
----
repo = Lutaml::Xsd::SchemaRepository.import_from_zip(
  zip_path: {path}
) <1>
----
<1> Import a repository from a ZIP package

Where,

`zip_path`:: Path to the ZIP file to import (required)

Returns a new `SchemaRepository` instance with all schemas and mappings
loaded.

.Importing a schema repository
[example]
====
[source,ruby]
----
# Import from previously exported ZIP
repo = Lutaml::Xsd::SchemaRepository.import_from_zip(
  zip_path: 'citygml_schemas.zip'
)

# Access metadata
metadata = repo.metadata
puts "Loaded: #{metadata[:name]} v#{metadata[:version]}"

# Repository is ready to use
result = repo.resolve_type(qualified_name: 'gml:CodeType')
puts "Type found: #{result.found?}"
----
====

=== Complete workflow example

.Comprehensive schema repository workflow
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

# 1. Create repository
repo = Lutaml::Xsd::SchemaRepository.new(
  base_dir: File.expand_path('spec/fixtures')
)

# 2. Configure namespaces
repo.add_namespace_mapping(prefix: 'gml', uri: 'http://www.opengis.net/gml/3.2')
repo.add_namespace_mapping(prefix: 'uro', uri: 'https://www.geospatial.jp/iur/uro/3.2')
repo.add_namespace_mapping(prefix: 'urf', uri: 'https://www.geospatial.jp/iur/urf/3.2')

# 3. Parse main schema with mappings
xsd_content = File.read('spec/fixtures/i-ur/urbanFunction.xsd')

schema_mappings = [
  {
    from: '../../uro/3.2/urbanObject.xsd',
    to: File.expand_path('spec/fixtures/i-ur/urbanObject.xsd')
  },
  {
    from: %r{(?:\.\./)+gml/(.+\.xsd)$},
    to: File.expand_path('spec/fixtures/gml/\1')
  }
]

result = repo.parse_schema(
  content: xsd_content,
  location: 'spec/fixtures/i-ur',
  schema_mappings: schema_mappings
)

puts "Parsed: #{result.location}"

# 4. Query statistics
stats = repo.statistics
puts "\nRepository Statistics:"
puts "  Schemas: #{stats[:total_schemas]}"
puts "  Namespaces: #{stats[:total_namespaces]}"
puts "  Types: #{stats[:total_types]}"
puts "  Elements: #{stats[:total_elements]}"

# 5. List all namespaces
puts "\nNamespaces:"
repo.namespaces.each do |uri|
  type_count = repo.types_in_namespace(uri).size
  puts "  #{uri} (#{type_count} types)"
end

# 6. Resolve types
puts "\nType Resolution:"
['gml:CodeType', 'uro:BuildingType', 'urf:UrbanFunctionType'].each do |qname|
  result = repo.resolve_type(qualified_name: qname)
  if result.found?
    puts "  âœ“ #{qname} -> #{result.type.name}"
  else
    puts "  âœ— #{qname} not found"
  end
end

# 7. Validate schemas
validation = repo.validate
puts "\nValidation: #{validation[:valid?] ? 'PASS' : 'FAIL'}"
validation[:errors].each { |e| puts "  Error: #{e}" }
validation[:warnings].each { |w| puts "  Warning: #{w}" }

# 8. Export to ZIP
repo.export_to_zip(
  output_path: 'schema_package.zip',
  metadata: {
    name: 'i-UR Schema Package',
    version: '3.2',
    description: 'Urban and Rural schemas with dependencies'
  }
)
puts "\nExported to schema_package.zip"

# 9. Import from ZIP (in a new session)
imported_repo = Lutaml::Xsd::SchemaRepository.import_from_zip(
  zip_path: 'schema_package.zip'
)
puts "Imported repository with #{imported_repo.schema_count} schemas"
----
====

This example demonstrates the complete lifecycle:

* Repository creation and configuration
* Schema parsing with imports
* Statistics and queries
* Type resolution
* Validation
* Package export and import

== Finding types with the Ruby API

=== General

The SchemaRepository provides multiple ways to find types, with important
nuances around namespace handling and resolution.

=== Basic type finding

.Finding a type by qualified name
[example]
====
[source,ruby]
----
require 'lutaml/xsd'

# Load package
repo = Lutaml::Xsd::SchemaRepository.from_package('schemas.lxr')

# Find using prefixed name (requires namespace registration)
result = repo.find_type('gml:CodeType')

if result.resolved?
  puts "Type: #{result.definition.name}"
  puts "Namespace: #{result.namespace}"
end
----
====

=== Namespace nuances

==== Prefixed names require namespace registration

Prefixed names like `gml:CodeType` require the prefix to be registered in
the namespace registry:

.Registering namespace prefixes
[example]
====
[source,ruby]
----
repo = Lutaml::Xsd::SchemaRepository.new

# Register prefix before using it
repo.add_namespace_mapping(
  prefix: 'gml',
  uri: 'http://www.opengis.net/gml/3.2'
)

# Now prefixed lookup works
result = repo.find_type('gml:CodeType')  # Works!
----

If you don't register the prefix first:

[source]
----
result = repo.find_type('gml:CodeType')
# Error: Namespace prefix 'gml' not registered
----
====

==== Clark notation doesn't require registration

Clark notation uses the full namespace URI in braces and doesn't require
prefix registration:

.Using Clark notation
[example]
====
[source,ruby]
----
# No prefix registration needed
result = repo.find_type('{http://www.opengis.net/gml/3.2}CodeType')

# Works immediately
puts result.definition.name if result.resolved?
----
====

==== Unprefixed names search all namespaces

Unprefixed names are searched across all namespaces:

.Searching with unprefixed names
[example]
====
[source,ruby]
----
# Searches all namespaces
result = repo.find_type('CodeType')

# May find the first match from any namespace
if result.resolved?
  puts "Found in namespace: #{result.namespace}"
end
----

WARNING: Unprefixed searches may return unexpected results if multiple
namespaces define types with the same name.
====

=== Package loading automatically registers namespaces

When loading from a package, namespace mappings are automatically registered:

.Automatic namespace registration from packages
[example]
====
[source,ruby]
----
# Load package (namespace mappings automatically registered)
repo = Lutaml::Xsd::SchemaRepository.from_package('schemas.lxr')

# Prefixed lookups work immediately
result = repo.find_type('gml:CodeType')  # Works!

# Check what namespaces are registered
repo.namespace_summary.each do |ns|
  puts "#{ns[:prefix]} => #{ns[:uri]}"
end
----
====

=== Finding attributes, elements, and groups

Beyond types, you can find other schema components:

.Finding schema components
[example]
====
[source,ruby]
----
# Find an attribute
attr = repo.find_attribute('xml:id')
puts "Attribute type: #{attr.type}" if attr

# Find an element
elem = repo.find_element('gml:Point')
puts "Element type: #{elem.type}" if elem

# Find a group
group = repo.find_group('gml:StandardObjectProperties')

# Find an attribute group
attr_group = repo.find_attribute_group('gml:AssociationAttributeGroup')
----
====

=== Cross-schema resolution

The repository resolves references across all schemas in the package:

.Cross-schema resolution example
[example]
====
[source,ruby]
----
# Type in schema A references attribute from schema B
repo = Lutaml::Xsd::SchemaRepository.from_package('multi-schema.lxr')

# Find the main type
result = repo.find_type('myns:MyType')

# Attributes are resolved across schemas
result.definition.attribute.each do |attr|
  if attr.ref
    # Resolve the attribute reference
    attr_def = repo.find_attribute(attr.ref)
    puts "#{attr.ref} => #{attr_def.type} (from #{attr_def.location})"
  end
end
----

This shows the power of lutaml-xsd: all cross-schema references are
automatically resolved, making it easy to understand complex multi-schema
applications.
====

=== See also

* link:docs/core-concepts/TYPE_RESOLUTION.adoc[Type resolution guide]
* link:docs/core-concepts/NAMESPACES.adoc[Namespace handling]
* link:docs/RUBY_API.adoc[Complete Ruby API reference]

[[serialization]]
== Serialization

=== General

The gem supports serializing the schema back to XML. Each class like
`Lutaml::Xsd::Schema` has a method `to_xml` that generates the XML
representation of the object.

=== Converting parsed schemas to XML

.Serializing a schema to XML
[example]
====
[source,ruby]
----
# Parse a schema
xsd_content = File.read('schema.xsd')
parsed_schema = Lutaml::Xsd.parse(xsd_content)

# Serialize back to XML
xml_output = parsed_schema.to_xml
puts xml_output

# Write to file
File.write('output.xsd', xml_output)
----
====

[[liquid-methods]]
== Liquid methods

=== General

This gem exposes convenient methods for use in Liquid templates via
`to_liquid` on parsed objects. These methods are particularly useful for
generating documentation and analyzing schema structures.

Below is a concise reference of the Liquid-enabled helpers organized by
module/type.

=== Element methods

The `Lutaml::Xsd::LiquidMethods::Element` module provides methods for working
with element objects in Liquid templates.

`used_by`:: Returns complex types that use or reference this element
`attributes`:: Returns attribute elements
`min_occurrences`:: Returns the element's minimum occurrences as Integer
  (default 1)
`max_occurrences`:: Returns `*` for unbounded, otherwise Integer (default 1)
`child_elements`:: Returns all nested child elements (resolved across
  groups/choices/sequences)
`referenced_type`:: Returns the name of the element's `type` if present, or
  the type name indicated by `ref` if defined
`referenced_object`:: Resolves and returns the element or its referenced
  element by `ref`
`referenced_complex_type`:: Resolves the complex type matching
  `referenced_type`

.Using element methods in Liquid templates
[example]
====
[source,liquid]
----
{% for el in schema.element %}
  Element: {{ el.name }} ({{ el.min_occurrences }}..{{ el.max_occurrences }})
  Type: {{ el.referenced_type }}
  {% assign attrs = el.attributes %}
  {% if attrs.size > 0 %}
    Attributes:
    {% for a in attrs %}
      - {{ a.referenced_name }} ({{ a.cardinality }})
    {% endfor %}
  {% endif %}
{% endfor %}
----
====

=== Attribute methods

The `Lutaml::Xsd::LiquidMethods::Attribute` module provides methods for
working with attribute objects in Liquid templates.

`referenced_object`:: Returns the actual attribute object, resolving
  references via `ref` if necessary
`referenced_name`:: Retrieves the definitive attribute name, using `ref` if
  not explicitly named
`referenced_type`:: Retrieves the fully resolved type name for this attribute
`cardinality`:: Returns `1` for required, `0..1` for optional

.Using attribute methods in Liquid templates
[example]
====
[source,liquid]
----
{% for a in complex_type.attribute %}
  {{ a.referenced_name }}: {{ a.referenced_type }} ({{ a.cardinality }})
{% endfor %}
----
====

=== AttributeGroup methods

The `Lutaml::Xsd::LiquidMethods::AttributeGroup` module provides methods for
working with attribute group objects in Liquid templates.

`used_by`:: Returns complex types that use this attribute group
`attribute_elements`:: Returns a flattened list of attributes, resolving
  nested groups

.Using attribute group methods in Liquid templates
[example]
====
[source,liquid]
----
{% for ag in schema.attribute_group %}
  Group {{ ag.name }} used by:
  {% for ct in ag.used_by %}
    - {{ ct.name }}
  {% endfor %}
  Attributes:
  {% for a in ag.attribute_elements %}
    - {{ a.referenced_name }}
  {% endfor %}
{% endfor %}
----
====

=== ComplexType methods

The `Lutaml::Xsd::LiquidMethods::ComplexType` module provides methods for
working with complex type objects in Liquid templates.

`used_by`:: Returns elements and group elements that reference this type
`attribute_elements`:: Returns all attributes (including those from groups
  and simple content extensions)
`child_elements`:: Returns all child elements (across
  sequences/choices/groups)
`find_elements_used(name)`:: Boolean indicating if an element name is used
  within this type

.Using complex type methods in Liquid templates
[example]
====
[source,liquid]
----
{% for ct in schema.complex_type %}
  ComplexType: {{ ct.name }}
  Elements:
  {% for el in ct.child_elements %}
    - {{ el.referenced_name }}
  {% endfor %}
  Attributes:
  {% for a in ct.attribute_elements %}
    - {{ a.referenced_name }}
  {% endfor %}
{% endfor %}
----
====

=== Group, Sequence, and Choice methods

The `Lutaml::Xsd::LiquidMethods::Group`, `...::Sequence`, and `...::Choice`
modules provide methods for working with these container objects in Liquid
templates.

`child_elements`:: Returns all nested `Element` instances contained within
`find_elements_used(name)`:: Boolean indicating if an element name is used
  within this container

.Using group methods in Liquid templates
[example]
====
[source,liquid]
----
{% for g in schema.group %}
  Group {{ g.name }} elements:
  {% for el in g.child_elements %}
    - {{ el.referenced_name }}
  {% endfor %}
{% endfor %}
----
====

=== SimpleContent methods

The `Lutaml::Xsd::LiquidMethods::SimpleContent` module provides methods for
working with simple content objects in Liquid templates.

`attribute_elements`:: Returns attributes coming from the `extension` and
  nested attribute groups

.Using simple content methods in Liquid templates
[example]
====
[source,liquid]
----
{% assign attrs = ct.simple_content.attribute_elements %}
{% for a in attrs %}
  - {{ a.referenced_name }}
{% endfor %}
----
====

=== Extension methods

The `Lutaml::Xsd::LiquidMethods::Extension` module provides methods for
working with extension objects in Liquid templates.

`attribute_elements`:: Returns attributes of the extension and its attribute
  groups

.Using extension methods in Liquid templates
[example]
====
[source,liquid]
----
{% for a in ct.simple_content.extension.attribute_elements %}
  - {{ a.referenced_name }}
{% endfor %}
----
====

=== ResolvedElementOrder methods

The `Lutaml::Xsd::LiquidMethods::ResolvedElementOrder` module provides a
helper method for maintaining original element order.

`resolved_element_order`:: Returns all elements in the order they originally
  appeared in the XSD

.Using resolved element order in Liquid templates
[example]
====
[source,liquid]
----
{% assign ordered = ct.resolved_element_order %}
{% for el in ordered %}
  {{ el.name }} (position preserved from XSD)
{% endfor %}
----
====

== Copyright

Copyright https://www.ribose.com[Ribose].

== License

The gem is available as open source under the terms of the
https://opensource.org/licenses/BSD-2-Clause[2-Clause BSD License].
