<div class="search-container">
  <div class="search-box">
    <label for="search-input" class="sr-only">Search schemas</label>
    <input
      type="search"
      id="search-input"
      class="search-input"
      placeholder="Search elements, types, attributes..."
      aria-label="Search schemas"
      autocomplete="off"
    >
    <span class="search-icon" aria-hidden="true">üîç</span>
  </div>

  {% if features.filtering.enabled %}
  <div class="filter-controls">
    <div class="filter-group">
      <label class="filter-label">Filter by type:</label>
      <div class="filter-options">
        {% for category in features.filtering.categories %}
        <label class="filter-option">
          <input
            type="checkbox"
            name="filter-{{ category }}"
            value="{{ category }}"
            class="filter-checkbox"
            checked
          >
          <span>{{ category | replace: '_', ' ' | capitalize }}</span>
        </label>
        {% endfor %}
      </div>
    </div>
  </div>
  {% endif %}

  <div id="search-results" class="search-results" role="region" aria-live="polite"></div>
</div>

<style>
  .search-container {
    margin-bottom: var(--spacing-lg);
    padding: var(--spacing-lg);
    background: var(--bg-secondary);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-sm);
  }

  .search-box {
    position: relative;
    margin-bottom: var(--spacing-md);
  }

  .search-input {
    width: 100%;
    padding: 0.75rem 3rem 0.75rem 1rem;
    font-size: 1rem;
    border: 2px solid var(--border-medium);
    border-radius: var(--radius-default);
    background: var(--bg-primary);
    color: var(--text-primary);
    transition: border-color var(--transition-duration);
  }

  .search-input:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  .search-icon {
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    font-size: 1.25rem;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  .filter-controls {
    margin-bottom: var(--spacing-md);
  }

  .filter-group {
    margin-bottom: var(--spacing-sm);
  }

  .filter-label {
    display: block;
    font-weight: 500;
    margin-bottom: 0.5rem;
    color: var(--text-secondary);
    font-size: 0.875rem;
  }

  .filter-options {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
  }

  .filter-option {
    display: flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.375rem 0.75rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-default);
    cursor: pointer;
    font-size: 0.875rem;
    transition: all var(--transition-duration);
  }

  .filter-option:hover {
    border-color: var(--color-primary);
    background: var(--bg-tertiary);
  }

  .filter-checkbox {
    cursor: pointer;
  }

  .search-results {
    max-height: 400px;
    overflow-y: auto;
  }

  .search-result {
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-default);
    transition: all var(--transition-duration);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
  }

  .search-result:hover {
    border-color: var(--color-primary);
    box-shadow: var(--shadow-sm);
  }

  .search-result .badge {
    flex-shrink: 0;
  }

  .search-result a {
    flex-grow: 1;
    font-weight: 500;
  }

  .search-result small {
    color: var(--text-muted);
    font-size: 0.75rem;
  }

  .no-results {
    text-align: center;
    padding: var(--spacing-lg);
    color: var(--text-muted);
  }

  .badge-element {
    background: var(--color-primary);
  }

  .badge-complex_type {
    background: var(--color-warning);
  }

  .badge-simple_type {
    background: var(--color-success);
  }

  .badge-attribute {
    background: var(--color-secondary);
  }

  @media (max-width: {{ theme.breakpoints.md }}) {
    .search-container {
      padding: var(--spacing-md);
    }

    .filter-options {
      flex-direction: column;
    }
  }
</style>

<script>
  // Enhanced search with filtering
  (function() {
    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');
    const filterCheckboxes = document.querySelectorAll('.filter-checkbox');

    if (!searchInput || !searchResults) return;

    let debounceTimer;
    const debounceDelay = {{ features.search.debounce_delay }};

    // Get active filters
    function getActiveFilters() {
      const filters = [];
      filterCheckboxes.forEach(checkbox => {
        if (checkbox.checked) {
          filters.push(checkbox.value);
        }
      });
      return filters;
    }

    // Perform search with debouncing
    searchInput.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        performSearch(e.target.value);
      }, debounceDelay);
    });

    // Re-search when filters change
    filterCheckboxes.forEach(checkbox => {
      checkbox.addEventListener('change', () => {
        performSearch(searchInput.value);
      });
    });

    function performSearch(query) {
      if (query.length < {{ features.search.min_characters }}) {
        searchResults.innerHTML = '';
        return;
      }

      const activeFilters = getActiveFilters();
      const results = search(query, activeFilters);
      displayResults(results, query);
    }

    function search(query, filters) {
      const lowerQuery = query.toLowerCase();
      const results = [];
      const data = Search.data || [];

      data.forEach(schema => {
        // Search elements
        if (filters.includes('elements') && schema.elements) {
          schema.elements.forEach(elem => {
            if (matchesQuery(elem, lowerQuery, 'elements')) {
              results.push({
                type: 'element',
                name: elem.name,
                schema: schema.name,
                documentation: elem.documentation
              });
            }
          });
        }

        // Search complex types
        if (filters.includes('complex_types') && schema.complex_types) {
          schema.complex_types.forEach(type => {
            if (matchesQuery(type, lowerQuery, 'complex_types')) {
              results.push({
                type: 'complex_type',
                name: type.name,
                schema: schema.name,
                documentation: type.documentation
              });
            }
          });
        }

        // Search simple types
        if (filters.includes('simple_types') && schema.simple_types) {
          schema.simple_types.forEach(type => {
            if (matchesQuery(type, lowerQuery, 'simple_types')) {
              results.push({
                type: 'simple_type',
                name: type.name,
                schema: schema.name,
                documentation: type.documentation
              });
            }
          });
        }

        // Search attributes
        if (filters.includes('attributes') && schema.attributes) {
          schema.attributes.forEach(attr => {
            if (matchesQuery(attr, lowerQuery, 'attributes')) {
              results.push({
                type: 'attribute',
                name: attr.name,
                schema: schema.name,
                documentation: attr.documentation
              });
            }
          });
        }
      });

      return results.slice(0, {{ features.search.max_results }});
    }

    function matchesQuery(item, query, type) {
      if (!item.name) return false;

      {% if features.search.fuzzy %}
      // Fuzzy matching
      return fuzzyMatch(item.name.toLowerCase(), query);
      {% else %}
      // Exact substring matching
      return item.name.toLowerCase().includes(query);
      {% endif %}
    }

    function fuzzyMatch(str, pattern) {
      let patternIdx = 0;
      let strIdx = 0;

      while (strIdx < str.length && patternIdx < pattern.length) {
        if (str[strIdx] === pattern[patternIdx]) {
          patternIdx++;
        }
        strIdx++;
      }

      return patternIdx === pattern.length;
    }

    function displayResults(results, query) {
      if (results.length === 0) {
        {% if features.search.highlight_matches %}
        searchResults.innerHTML = '<p class="no-results">No results found for "' + escapeHtml(query) + '"</p>';
        {% else %}
        searchResults.innerHTML = '<p class="no-results">No results found</p>';
        {% endif %}
        return;
      }

      const html = results.map(r => {
        const highlightedName = {% if features.search.highlight_matches %}highlightMatches(r.name, query){% else %}escapeHtml(r.name){% endif %};

        return `<div class="search-result">
          <span class="badge badge-${r.type}">${formatType(r.type)}</span>
          <a href="#${r.name}">${highlightedName}</a>
          <small>${escapeHtml(r.schema)}</small>
        </div>`;
      }).join('');

      searchResults.innerHTML = html;
    }

    function highlightMatches(text, query) {
      const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
      return escapeHtml(text).replace(regex, '<mark>$1</mark>');
    }

    function formatType(type) {
      return type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
  })();
</script>